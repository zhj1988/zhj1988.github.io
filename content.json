{"meta":{"title":"ZHuanJ——blog","subtitle":null,"description":null,"author":"ZHuanJ","url":"https://zhj1988.github.io","root":"zhj1988.github.io/"},"pages":[{"title":"board","date":"2019-07-08T14:55:51.000Z","updated":"2019-07-08T14:55:51.421Z","comments":true,"path":"board/index.html","permalink":"https://zhj1988.github.io/board/index.html","excerpt":"","text":""}],"posts":[{"title":"微信公众号网页授权与模板消息发送","slug":"微信公众号网页授权与模板消息发送","date":"2019-09-25T08:57:10.000Z","updated":"2019-09-26T07:06:57.693Z","comments":true,"path":"2019/09/25/微信公众号网页授权与模板消息发送/","link":"","permalink":"https://zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/","excerpt":"简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。本文章共分为三部分： 一、微信网页授权登陆二、公众号模板消息发送三、微信分享","text":"简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。本文章共分为三部分： 一、微信网页授权登陆二、公众号模板消息发送三、微信分享 微信网页授权登陆1.微信开发文档首先一定要先了解清除微信开发文档，明白传参的含义以及各自的差别； 开发文档地址：https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html 比如其中的 1）关于网页授权的两种scope的区别说明 a、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面） b、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。 2）关于网页授权access_token和普通access_token的区别 a、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息； b、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。 3）如果是多应用联合，则需注意UnionID机制，ex：如淘宝，支付宝这关联账户，unionid也应用于来区分用户的唯一性 2.流程（非静默授权）1）、引导用户进入授权页面同意授权，获取code 2）、通过code换取网页授权access_token（与基础支持中的access_token不同） 3）、如果需要，开发者可以刷新网页授权access_token，避免过期 4）、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制） 关于这四个步骤相信熟读微信开发文档的伙伴肯定很熟悉，我就讲解一下其中的一些细节部分； 第一个，是关于前后端分离的项目怎么分配工作，根据微信开发文档，access_token不能暴露在客户端，因此1获取code的工作由前端完成；2，3，4三个步骤在后台完成工作，拉取用户信息后，存入数据库并返回给前端； 第二个，相信很多伙伴一开始没有微信公众号可以测试（如果公司有提供测试当我没说），微信公众号申请又有点繁琐，所以我推荐一开始开发使用，微信公众号平台接口测试：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 只需要一个微信号，即可开始简便开发，关于测试平台与正式微信公众号平台的细微差别，我会在讲解的过程中提及； 3.具体实现过程ok，我们现在正式从四个步骤开始第一步 获取code前端在进入首页时，在js中先向微信发送请求：https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect这一步很简单，但是涉及配置的东西较多； 1.APPID：测试号中，很容易就找到，正式的微信公众号，找不到的话就百度吧，这个没什么好说的 2.scope：作用域，第一点的微信开发文档也说过了，需要用户点击授权登陆，此时scope=snsapi_userinfo； 3.state:此参数相当与传参的作用，表明是由此网页发送的，作为一个身份识别，例如用户点击授权登陆之后，会带着从微信官方获得的code以及你发送的state返回至回调地址，如果是多网页不同的登陆操作，可以通过设置state不同来对应处理code（博主对前端也不是特别熟悉，此处猜测state其作用），如果只是简单的登陆授权，state不设置或者为1234即可； 4.redirect_uri：回调地址，其作用为，当你发送请求后，微信用户点击确认后跳转的地址，查看响应头可知，回调地址必须为text-html，不能为接口；表现形式为：url？code=XXXX&amp;state=XXX；另外，最重要的就是公众号的配置：a）测试号配置：在此处配置你的域名 b）微信公众号配置：在功能设置中设置 同时一定要下载这个文件 并配置在你项目根目录下（ =_= 简单的解释就是，当你的项目运行时候，路径：你的域名/文件名，即可访问到该文件，我用的是springboot 只需要在mvc配置类中做一个静态资源的映射即可，或者在application.yml中添加配置路径即可，如果使用的是tomcat或者apache 不需有项目配置路径，丢到相应的webapp或者html文件夹下即可，具体可自行上网搜索） 至此第一步实现过程以及配置过程结束； 第二步后台获取用户信息 1.添加pom依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.liyiorg&lt;/groupId&gt; &lt;artifactId&gt;weixin-popular&lt;/artifactId&gt; &lt;version&gt;2.8.17&lt;/version&gt; &lt;/dependency&gt;2.获取用户信息 public static Map&lt;String,Object&gt; goToIndex( String code,Integer id){ Map&lt;String,Object&gt; map =new HashMap&lt;&gt;(); map.put(&quot;code&quot;,code); System.out.println(&quot;code: &quot;+code); if(code==null||&quot;&quot;.equals(code)){ // return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;code为空&quot;); map.put(&quot;error&quot;,&quot;code为空&quot;); return map; } SnsToken snsToken = SnsAPI.oauth2AccessToken(appID, appSecret, map.get(&quot;code&quot;).toString()); String errcode = snsToken.getErrcode(); if(errcode!=null&amp;&amp;!&quot;&quot;.equals(errcode)){ //return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;微信获取出错&quot;); map.put(&quot;error&quot;,&quot;微信获取出错&quot;); return map; } User user = SnsAPI.userinfo(snsToken.getAccess_token(), snsToken.getOpenid(), &quot;zh_CN&quot;,1); String errcode1 = user.getErrcode(); if(errcode1!=null&amp;&amp;!&quot;&quot;.equals(errcode1)){ map.put(&quot;error&quot;,&quot;微信获取信息出错&quot;); return map; //return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;微信获取信息出错&quot;); } return map; }注意配置appid，appSecret（测试号可以直接看，微信公众号appid也可以查到，但是appsecret由于安全问题，在公众号内并不保持，具体就要问运营者了） 以上只是简单使用access_token获取用户信息；SnsToken snsToken = SnsAPI.oauth2AccessToken(appID, appSecret, map.get(“code”).toString());如果为非静默授权，你可以获得一个refresh_token 用于刷新access_token。snsToken.getRefresh_token();参考微信开发文档： 由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。 请求方法 获取第二步的refresh_token后，请求以下链接获取access_token：https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKENappid 是 公众号的唯一标识grant_type 是 填写为refresh_tokenrefresh_token 是 填写通过access_token获取到的refresh_token参数以上参数均可获得； 参考SnsToken源码中也有刷新方法： public static SnsToken oauth2RefreshToken(String appid, String refresh_token) { HttpUriRequest httpUriRequest = RequestBuilder.post().setUri(&quot;https://api.weixin.qq.com/sns/oauth2/refresh_token&quot;).addParameter(&quot;appid&quot;, appid).addParameter(&quot;refresh_token&quot;, refresh_token).addParameter(&quot;grant_type&quot;, &quot;refresh_token&quot;).build(); return (SnsToken)LocalHttpClient.executeJsonResult(httpUriRequest, SnsToken.class); }（不得不感慨，Java确实方便，不少现成的jar包提供给他人） 记得保存refresh_token 用于之后用户登陆的刷新； 综上，是不是觉得获取微信用户信息十分方便，然而其中也有很多曲折，一路摸索过来，反而是使用code获取用户信息这一复杂的步骤比较轻松，更多的时间在配置文件，以前端的测试；对了还有两个很重要的点，使用微信web开发工具测试授权登陆时候，微信用户一定要先关注测试号（如果是正式公众号则会弹窗关注该公众号）；其次前端项目，必须上传到服务器测试授权登陆，本地不能测试（=_= 不过回调地址能理解的话，就不会在本地测试授权登陆了） 公众号消息模板发送一.微信开发文档万变不离其宗，首先我们先来看下微信开发文档中对消息模板的介绍： 1、所有服务号都可以在功能-&gt;添加功能插件处看到申请模板消息功能的入口，但只有认证后的服务号才可以申请模板消息的使用权限并获得该权限；2、需要选择公众账号服务所处的2个行业，每月可更改1次所选行业；3、在所选择行业的模板库中选用已有的模板进行调用；4、每个账号可以同时使用25个模板。5、当前每个账号的模板消息的日调用上限为10万次，单个模板没有特殊限制。上述介绍了什么为消息模板，首先选择公众号所属行业，再从模板需要从模板库下载，而如果需要符合自身的消息模板，则需要申请（审核需要5——7天） 关于接口文档，请注意： 1、模板消息调用时主要需要模板ID和模板中各参数的赋值内容； 2、模板中参数内容必须以&quot;.DATA&quot;结尾，否则视为保留字； 3、模板保留符号&quot;{{ }}&quot;。 上诉表明了参数的规则 二.实现过程1.配置相应的appid，appsecret，templateId（模板id）2.编程：1）添加pom依赖 &lt;!--微信模版消息推送三方sdk--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt;2)工具类中： public static Map&lt;String,Object&gt; push1(String templateId, StudyClock studyClock){ Map&lt;String,Object&gt;map = new HashMap&lt;&gt;(); //1，配置 WxMpService wxMpService = build2(); //2,推送消 WxMpTemplateMessage templateMessage = build1(templateId,openid); //3,如果是正式版发送模版消息，这里需要配置你的信息 templateMessage.addData(new WxMpTemplateData(&quot;first&quot;, &quot;提醒内容&quot;, &quot;#85ffc3&quot;)); templateMessage.addData(new WxMpTemplateData(&quot;remark1&quot;, &quot;提醒内容&quot;, &quot;#85ffc3&quot;)); return send(wxMpService,templateMessage); } private static WxMpTemplateMessage build1(String templateId, String openid ){ //2,推送消息 WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder() .toUser(openid)//要推送的用户openid .templateId(templateId)//模版id .url(&quot;url&quot;)//点击模版消息要访问的网址 .build(); return templateMessage; } private static WxMpService build2( ){ //2,推送消息 WxMpInMemoryConfigStorage wxStorage = new WxMpInMemoryConfigStorage(); wxStorage.setAppId(appID); wxStorage.setSecret(appSecret); WxMpService wxMpService = new WxMpServiceImpl(); wxMpService.setWxMpConfigStorage(wxStorage); return wxMpService; } private static Map&lt;String,Object&gt; send(WxMpService wxMpService,WxMpTemplateMessage templateMessage ){ Map&lt;String,Object&gt;map = new HashMap&lt;&gt;(); try { wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage); map.put(&quot;msg&quot;,&quot;微信提醒发送成功&quot;); } catch (Exception e) { System.out.println(&quot;推送失败：&quot; + e.getMessage()); map.put(&quot;msg&quot;,&quot;推送失败：&quot; + e.getMessage()); e.printStackTrace(); }finally { return map; } }上述程序已基本总结完毕，openid为微信用户的openid，用户发送至相应的微信账号（这个可从第一步获得） 除了运用现成的jar包，也可以使用HttpClient等jar包，直接向微信官方请求接口，使用JsonObject 接收返回参数，再做相应的判断也即可； 微信分享一.简介当我们在公众号的页面时候，点击右上角即有一个分享功能，分享给好友，分享给朋友圈，前端就会生成相应的连接，此时就运用到了微信分享功能的一些知识；首先声明，我只是一名后端小程序员，对于前端的很多事情并不理解，所以对于前端的一些布置就简单掠过； 二.配置环境在微信公众号平台中，设置js安全域名 ；以及部署的服务器ip添加到ip白名单 三.主要过程前端生成分享链接，需要后台生成签名以及其他数据； 主要过程：1.获取access_token；2.获取jsapi_ticket；3.生成签名;4.把签名和随机串和appid和时间戳发回给前端； access_token每天获取有上限，而且有效期为7200s 两个小时，所以需要在后台缓存该数据（如果不同或者嫌麻烦就存在数据库吧）这里我使用的是session缓存，说一下关于缓存的坑（以下仅关于springboot）； 1）首先设置session过期时间，在springboot 配置文件中设置即可server.servlet.session.timeout=5400s(一个半小时)，设置完后你会发现，过了几秒，缓存就不见了，并不像配置文件中所诉一下；此处出现第一个坑，原因为springBoot2.x版本以上，过期时间的写法作了调整，所以更改为server.servlet.session.timeout=PT90M具体写法参考： https://blog.csdn.net/heart_mine/article/details/89176410 简述一下：字符串类似数字有正负之分,默认正,负以’-‘开头,紧接着’P’,下面所有字母都不区分大小写:‘D’ – 天‘H’ – 小时‘M’ – 分钟‘S’ – 秒字符’T’是紧跟在时分秒之前的，每个单位都必须由数字开始,且时分秒顺序不能乱,比如:P2DT3M5S,P3D,PT3S，PT3M2S 等于 -PT-3M-2S 2）设置完过期时间，本来兴高采烈的，但是测试的时候发现，session的过期时间已经到了，但是仍然可以获取到数据，而不用再存入缓存，此时我懵逼了，再三测试以及联想ehcache缓存一些知识，我终于知道怎么填这个坑了；session的过期时间，即使活跃时间，简单解释即，当你设置一分钟的过期时间，你在一分钟内不访问缓存，缓存即失效，而当你在一分钟内访问缓存，过期时间即会被刷新 至此session过期时间的神秘面纱终于被揭露。 3）综上，由于活跃时间的设计，access_token也会面临在缓存中存在而使用其请求的时候失效的问题，所以我们可以设置一个时间戳，在存入缓存的同时，也将时间戳存入，当取出缓存时候，对比现在的时间戳，如果已经过了失效时间，即重新请求，这么简单的算法我就不贴出来了，关于时间戳的问题，大家也可以百度搜索即可。 四.代码编写首先，关于生成的签名，由于要经过相应的算法加密，所以对生成的算法签名验证问题，我推荐微信官方一个验证网站；链接：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign 代码如下： @GetMapping(value = &quot;/share&quot;) @ResponseBody public Map&lt;String,Object&gt; share(HttpServletRequest request){ Map&lt;String, Object&gt;map = new HashMap&lt;&gt;(); HttpSession session=request.getSession(); String url =request.getParameter(&quot;url&quot;); String accessToken =&quot;&quot;; String jsapi_ticket =&quot;&quot;; accessToken = wxUtil.getAccessToken(); session.setAttribute(&quot;accessToken&quot;,accessToken); System.out.println(&quot;accessToken保存至缓存中&quot;); jsapi_ticket = wxUtil.getTicket(accessToken); session.setAttribute(&quot;jsapi_ticket&quot;,jsapi_ticket); System.out.println(&quot;jsapi_ticket保存至缓存中&quot;); //3、时间戳和随机字符串 String noncestr = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 16);//随机字符串 String timestamp = String.valueOf(System.currentTimeMillis() / 1000);//时间戳 System.out.println(&quot;accessToken:&quot;+accessToken+&quot;\\njsapi_ticket:&quot;+jsapi_ticket+&quot;\\n时间戳：&quot;+timestamp+&quot;\\n随机字符串：&quot;+noncestr); //4、将参数排序并拼接字符串 String str = &quot;jsapi_ticket=&quot;+jsapi_ticket+&quot;&amp;noncestr=&quot;+noncestr+&quot;&amp;timestamp=&quot;+timestamp+&quot;&amp;url=&quot;+url; //5、将字符串进行sha1加密 String signature =SHA1(str); System.out.println(&quot;参数：&quot;+str+&quot;\\n签名：&quot;+signature); map.put(&quot;appId&quot;,appID); map.put(&quot;timestamp&quot;,timestamp); map.put(&quot;noncestr&quot;,noncestr); map.put(&quot;signature&quot;,signature); return map; } //以下为其他获取方法，大部分也是我从网上copy来的 public static String getAccessToken() { String access_token = &quot;&quot;; String grant_type = &quot;client_credential&quot;;//获取access_token填写client_credential String AppId=appID;//第三方用户唯一凭证 String secret=appSecret;//第三方用户唯一凭证密钥，即appsecret //这个url链接地址和参数皆不能变 String url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=&quot;+grant_type+&quot;&amp;appid=&quot;+AppId+&quot;&amp;secret=&quot;+secret; try { URL urlGet = new URL(url); HttpURLConnection http = (HttpURLConnection) urlGet.openConnection(); http.setRequestMethod(&quot;GET&quot;); // 必须是get方式请求 http.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); http.setDoOutput(true); http.setDoInput(true); System.setProperty(&quot;sun.net.client.defaultConnectTimeout&quot;, &quot;30000&quot;);// 连接超时30秒 System.setProperty(&quot;sun.net.client.defaultReadTimeout&quot;, &quot;30000&quot;); // 读取超时30秒 http.connect(); InputStream is = http.getInputStream(); int size = is.available(); byte[] jsonBytes = new byte[size]; is.read(jsonBytes); String message = new String(jsonBytes, &quot;UTF-8&quot;); JSONObject demoJson = JSONObject.parseObject(message); System.out.println(&quot;JSON字符串：&quot;+demoJson); access_token = demoJson.getString(&quot;access_token&quot;); is.close(); } catch (Exception e) { e.printStackTrace(); } return access_token; } public static String getTicket(String access_token) { String ticket = null; String url = &quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&quot;+ access_token +&quot;&amp;type=jsapi&quot;;//这个url链接和参数不能变 try { URL urlGet = new URL(url); HttpURLConnection http = (HttpURLConnection) urlGet.openConnection(); http.setRequestMethod(&quot;GET&quot;); // 必须是get方式请求 http.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); http.setDoOutput(true); http.setDoInput(true); System.setProperty(&quot;sun.net.client.defaultConnectTimeout&quot;, &quot;30000&quot;);// 连接超时30秒 System.setProperty(&quot;sun.net.client.defaultReadTimeout&quot;, &quot;30000&quot;); // 读取超时30秒 http.connect(); InputStream is = http.getInputStream(); int size = is.available(); byte[] jsonBytes = new byte[size]; is.read(jsonBytes); String message = new String(jsonBytes, &quot;UTF-8&quot;); JSONObject demoJson = JSONObject.parseObject(message); System.out.println(&quot;JSON字符串：&quot;+demoJson); ticket = demoJson.getString(&quot;ticket&quot;); is.close(); } catch (Exception e) { e.printStackTrace(); } return ticket; } public static String SHA1(String decript) { try { MessageDigest digest = java.security.MessageDigest.getInstance(&quot;SHA-1&quot;); digest.update(decript.getBytes()); byte messageDigest[] = digest.digest(); // Create Hex String StringBuffer hexString = new StringBuffer(); // 字节数组转换为 十六进制 数 for (int i = 0; i &lt; messageDigest.length; i++) { String shaHex = Integer.toHexString(messageDigest[i] &amp; 0xFF); if (shaHex.length() &lt; 2) { hexString.append(0); } hexString.append(shaHex); } return hexString.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return &quot;&quot;; }至此生成签名代码代码已结束； 总结：微信官方文档齐全，网上可借鉴模板也多，在开发过程中遇到困难，不要急于寻找其他方法，了解前因后果，才是解决困难的捷径；之后会将微信小程序，微信支付等其他相关知识再完善；","categories":[],"tags":[]},{"title":"Spring Boot 缓存应用——ehcache","slug":"Spring-Boot-缓存应用——ehcache","date":"2019-09-09T14:45:36.000Z","updated":"2019-09-09T15:39:46.182Z","comments":true,"path":"2019/09/09/Spring-Boot-缓存应用——ehcache/","link":"","permalink":"https://zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/","excerpt":"简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项目中的应用，对ehcache做一个介绍；","text":"简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项目中的应用，对ehcache做一个介绍； 本篇文章分为两个部分学习一、原理分析二、实际应用 一、原理分析1.缓存的由来 缓存要解决的问题：一个程序的瓶颈在于数据库，我们也知道内存的速度是大大快于硬盘的速度的。当我们需要重复地获取相同的数据的时候，我们一次又一次的请求数据库或者远程服务，导致大量的时间耗费在数据库查询或者远程方法调用上，导致程序性能的恶化，这便是数据缓存要解决的问题。 2.缓存的分类 类似的缓存技术有：Redis、EhCache、Guava等，现在一般常用的为Redis。 二、实际应用我们从一个简单的例子入手：前端发送 用户手机获取验证码的请求；后端发送验证码并保存在缓存中（限时五分钟）；前端登陆，用户填写验证码发送会后台；后台比较验证码是否存在，以及验证码是否与缓存一致；完成验证操作。 1.首先很好理解，缓存作为一个暂时存在的存储结构，保存一些时间限制的东西，当然同理也可以通过保存数据库，查询校验的方式来实现同等操作，但是缓存结构减少了删除操作，个人理解将内存负担又客户端来承受，扯回到实际应用中，缓存中保存是以Map中等同的&lt;key,value&gt;,一对一的映射进行存储，这样即可分辨出验证码对应登陆手机号是否一致； 2.介绍完毕，首先在SprinpBoot中pom.xml中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;/dependency&gt;3.在启动类即引导类上 添加注解@EnableCaching （有些版本不需要添加） 4.缓存在ehcache中的value 对象需要引用接口序列化 implements Serializable 5.在resource路劲下添加ehcache配置文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot; /&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;1000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;0&quot; timeToLiveSeconds=&quot;100&quot; memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt; &lt;cache name=&quot;cache&quot; eternal=&quot;false&quot; #是否永久缓存 maxElementsInMemory=&quot;100&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;0&quot; #最大闲置时间 timeToLiveSeconds=&quot;30&quot; #最大缓存时间 memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt; &lt;/ehcache&gt;具体属性参考下文： (1).diskStore： 为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录user.dir – 用户当前工作目录java.io.tmpdir – 默认临时文件路径(2).defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。(3).cache：自定缓存策略，为自定义的缓存策略。参数解释如下：cache元素的属性：name：缓存名称maxElementsInMemory：内存中最大缓存对象数maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为falseoverflowToDisk：true表示当内存缓存的对象数目达到了maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。diskPersistent：是否缓存虚拟机重启期数据diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。 timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 6.创建配置类config @Configuration @EnableCaching public class EhCacheConfig { @Value(&quot;${spring.cache.ehcache.config}&quot;) private String ehCacheCongifPath; @Bean public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() { EhCacheManagerFactoryBean cacheManagerFactoryBean = new EhCacheManagerFactoryBean(); System.out.println(ehCacheCongifPath); cacheManagerFactoryBean.setConfigLocation(new ClassPathResource(ehCacheCongifPath)); cacheManagerFactoryBean.setShared(true); //如果 Factory 自己手动实列化，需要 执行afterPropertiesSet()方法，因为这是方法是 初始化 类使用的 //如果Factory 由Spring 容器 创建 ，容器初始化完成后 spring 会去执行这个方法。 //cacheManagerFactoryBean.afterPropertiesSet(); // 初始化 读取配置文件, return cacheManagerFactoryBean; } @Bean public CacheManager compositeCacheManager(@Autowired EhCacheManagerFactoryBean factoryBean) { //RedisCacheManager redisCacheManager = getRedisCacheManager(redisTemplate); //GuavaCacheManager guavaCacheManager = getGuavaCacheManager(); EhCacheCacheManager ehCacheCacheManager = ehCacheCacheManager(factoryBean); CompositeCacheManager cacheManager = new CompositeCacheManager(ehCacheCacheManager); cacheManager.setFallbackToNoOpCache(true); cacheManager.afterPropertiesSet(); return cacheManager; } private EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean factoryBean) { //由于自己实列化EhCacheManager 需要执行 手动初始化 方法。 EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager(factoryBean.getObject()); //初始化 ehCacheCacheManager.initializeCaches(); return ehCacheCacheManager; } }7.进入实际应用，在service实现类中，在类或者方法上添加注解（不同地方表示注解范围不同） 介绍一下三个主要的注解@CachePut表示缓存新添加的数据或者更新的数据到缓存中；@CacheEvict表示清除缓存；@Cacheable表示添加数据到缓存中，如果缓存中已有对应的值，则不更新； 使用注解时候注意地方example1（存缓存）： @CachePut(value=&quot;verifications&quot;,key=&quot;#phone&quot;) public Verification createVerification(String phone) { Verification verification = new Verification(); verification.setPhone(phone); verification.setCheckCode(&quot;1234&quot;); System.out.println(verification.toString()); return verification; }首先注解的参数#phone 必须为方法的参数；其次value=“name” 为ehcache中 name的命名（好像可以自己命名，待测试）；最后缓存保持的值，为方法返回的值，没错，就是方法返回的值，如果你返回对象，缓存即为对象，如果是String数据，缓存即为String； example2： @Cacheable(value = &quot;verifications&quot;,key = &quot;#phone&quot;) public Verification checkCode(String phone) { return null; }在此例子中，若缓存已有保存数据，则返回缓存中的值，若无，则返回null； 综上，ehcache的实际应用还有注意点以及介绍完毕，当然关于其更多的应用则是应用在数据库查询上，当添加注解后，其方法执行，若是方法查询的参数一致，则不会访问数据库，直接返回缓存中的数据； 参考博客：1.https://blog.csdn.net/open_yu/article/details/806545552.https://blog.csdn.net/smartdt/article/details/78733203","categories":[],"tags":[]},{"title":"html与js 学习笔记","slug":"html与js-学习笔记","date":"2019-08-07T07:43:13.000Z","updated":"2019-08-11T08:41:44.369Z","comments":true,"path":"2019/08/07/html与js-学习笔记/","link":"","permalink":"https://zhj1988.github.io/2019/08/07/html与js-学习笔记/","excerpt":"最近学习使用bootstrap搭建一个后台管理系统，需要熟悉前段页面的一些语法操作，所以记录一下html与js 学习过程的一些笔记。","text":"最近学习使用bootstrap搭建一个后台管理系统，需要熟悉前段页面的一些语法操作，所以记录一下html与js 学习过程的一些笔记。 第一部分关于html基本语法一、html入门总结1.元素（规范写法：需要开始标签和结束标签） &lt;p&gt; 这是一个段落 &lt;/p&gt; &lt;a href=&quot;default.htm&quot;&gt; 这是一个链接 &lt;/a&gt; &lt;br&gt; 换行 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 &lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。 推荐使用小写标签 &lt;hr&gt; 标签在 HTML 页面中创建水平线。 超链接文本 &lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到&quot;有用的提示部分(id=&quot;tips&quot;）&quot;： &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;2.属性 HTML 属性HTML 元素可以设置属性属性可以在元素中添加附加信息属性一般描述于开始标签属性总是以名称/值对的形式出现，比如：name=”value”。 accesskey 设置访问元素的键盘快捷键。 class 规定元素的类名（classname） contenteditableNew 规定是否可编辑元素的内容。 contextmenuNew 指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单 data-*New 用于存储页面的自定义数据 dir 设置元素中内容的文本方向。 draggableNew 指定某个元素是否可以拖动 dropzoneNew 指定是否将数据复制，移动，或链接，或删除 hiddenNew hidden 属性规定对元素进行隐藏。 id 规定元素的唯一 id lang 设置元素中内容的语言代码。 spellcheckNew 检测元素是否拼写错误 style 规定元素的行内样式（inline style） tabindex 设置元素的 Tab 键控制次序。 title 规定元素的额外信息（可在工具提示中显示） translateNew 指定是否一个元素的值在页面载入时是否需要翻译3.属性引发事件 属性 值 描述 onblur script 当元素失去焦点时运行脚本 onchange script 当元素改变时运行脚本 oncontextmenuNew script 当触发上下文菜单时运行脚本 onfocus script 当元素获得焦点时运行脚本 onformchangeNew script 当表单改变时运行脚本 onforminputNew script 当表单获得用户输入时运行脚本 oninputNew script 当元素获得用户输入时运行脚本 oninvalidNew script 当元素无效时运行脚本 onreset script 当表单重置时运行脚本。HTML 5 不支持。 onselect script 当选取元素时运行脚本 onsubmit script 当提交表单时运行脚本 键盘事件（Keyboard Events） 属性 值 描述 onkeydown script 当按下按键时运行脚本 onkeypress script 当按下并松开按键时运行脚本 onkeyup script 当松开按键时运行脚本 鼠标事件（Mouse Events） 通过鼠标触发事件, 类似用户的行为: 属性 值 描述 onclick script 当单击鼠标时运行脚本 ondblclick script 当双击鼠标时运行脚本 ondragNew script 当拖动元素时运行脚本 ondragendNew script 当拖动操作结束时运行脚本 ondragenterNew script 当元素被拖动至有效的拖放目标时运行脚本 ondragleaveNew script 当元素离开有效拖放目标时运行脚本 ondragoverNew script 当元素被拖动至有效拖放目标上方时运行脚本 ondragstartNew script 当拖动操作开始时运行脚本 ondropNew script 当被拖动元素正在被拖放时运行脚本 onmousedown script 当按下鼠标按钮时运行脚本 onmousemove script 当鼠标指针移动时运行脚本 onmouseout script 当鼠标指针移出元素时运行脚本 onmouseover script 当鼠标指针移至元素之上时运行脚本 onmouseup script 当松开鼠标按钮时运行脚本 onmousewheelNew script 当转动鼠标滚轮时运行脚本 onscrollNew script 当滚动元素的滚动条时运行脚本4.文本标签 &lt;b&gt; 定义粗体文本 &lt;em&gt; 定义着重文字 &lt;i&gt; 定义斜体字 &lt;small&gt; 定义小号字 &lt;strong&gt; 定义加重语气 &lt;sub&gt; 定义下标字 &lt;sup&gt; 定义上标字 &lt;ins&gt; 定义插入字 &lt;del&gt; 定义删除字 &lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;一个段落。&lt;/p&gt;5.head元素 HTML head 元素 标签 描述 &lt;head&gt; 定义了文档的信息 &lt;title&gt; 定义了文档的标题 &lt;base&gt; 定义了页面链接标签的默认链接地址 &lt;link&gt; 定义了一个文档和外部资源之间的关系 &lt;meta&gt; 定义了HTML文档中的元数据 &lt;script&gt; 定义了客户端的脚本文件 &lt;style&gt; 定义了HTML文档的样式文件6.图片 &lt;img&gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。 alt 属性用来为图像定义一串预备的可替换的文本。height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。 &lt;img src=&quot;url&quot; alt=&quot;some_text&quot;width=&quot;304&quot; height=&quot;228&quot;&gt;7.表格 表格的表头使用 &lt;th&gt; 标签进行定义。 大多数浏览器会把表头显示为粗体居中的文本： border=&quot;1&quot;，外边框宽度 &lt;caption&gt; 标签定义表格的标题。 &lt;caption&gt; 标签必须直接放置到 &lt;table&gt; 标签之后。 &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;8.列表 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 无序列表使用 &lt;ul&gt; 标签 &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; 同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。 列表项使用数字来标记。 &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; &lt;ol&gt; 定义有序列表 &lt;ul&gt; 定义无序列表 &lt;li&gt; 定义列表项 &lt;dl&gt; 定义列表 &lt;dt&gt; 自定义列表项目 &lt;dd&gt; 定义自定列表项的描述9.区块布局 HTML 分组标签 标签 描述 &lt;div&gt; 定义了文档的区域，块级 (block-level) &lt;span&gt; 用来组合文档中的行内元素， 内联元素(inline)10.表单元素 表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 表单使用表单标签 &lt;form&gt; 来设置: 文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定 密码字段通过标签&lt;input type=&quot;password&quot;&gt; 来定义: 单选按钮（Radio Buttons） &lt;input type=&quot;checkbox&quot;&gt; 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 &lt;input type=&quot;submit&quot;&gt; 定义了提交按钮. 当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。: 标签 描述 &lt;form&gt; 定义供用户输入的表单 &lt;input&gt; 定义输入域 &lt;textarea&gt; 定义文本域 (一个多行的输入控件) &lt;label&gt; 定义了 &lt;input&gt; 元素的标签，一般为输入标题 &lt;fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来 &lt;legend&gt; 定义了 &lt;fieldset&gt; 元素的标题 &lt;select&gt; 定义了下拉选项列表 &lt;optgroup&gt; 定义选项组 &lt;option&gt; 定义下拉列表中的选项 &lt;button&gt; 定义一个点击按钮 &lt;datalist&gt;New 指定一个预先定义的输入控件选项列表 &lt;keygen&gt;New 定义了表单的密钥对生成器字段 &lt;output&gt;New 定义一个计算结果11.框架iframe iframe语法: &lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt; 该URL指向不同的网页。 Iframe - 设置高度与宽度 height 和 width 属性用来定义iframe标签的高度与宽度。 属性默认以像素为单位, 但是你可以指定其按比例显示 (如：&quot;80%&quot;)。 实例 &lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; 尝试一下 » Iframe - 移除边框 frameborder 属性用于定义iframe表示是否显示边框。 设置属性值为 &quot;0&quot; 移除iframe的边框: 实例 &lt;iframe src=&quot;demo_iframe.htm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 尝试一下 » 使用iframe来显示目标链接页面 iframe可以显示一个目标链接的页面 目标链接的属性必须使用iframe的属性，如下实例: 实例 &lt;iframe src=&quot;demo_iframe.htm&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot; target=&quot;iframe_a&quot;&gt;RUNOOB.COM&lt;/a&gt;&lt;/p&gt;12.字符实体规范 实体（Entities） &amp;lt; 等同于 &lt; &amp;gt; 等同于 &gt; &amp;#169; 等同于 ©第二部分关于java Script一、java script入门知识1.example &lt;script&gt; function changeImage() { element=document.getElementById(&apos;myimage&apos;) if (element.src.match(&quot;bulbon&quot;)) { element.src=&quot;/images/pic_bulboff.gif&quot;; } else { element.src=&quot;/images/pic_bulbon.gif&quot;; } } &lt;/script&gt; &lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt;通过 element=document.getElementById(‘myimage’)获取元素，并对其相应修改 2.JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。使用 document.write() 方法将内容写到 HTML 文档中。使用 innerHTML 写入到 HTML 元素。使用 console.log() 写入到浏览器的控制台。 3.javaScript 变量 var cars=new Array(); cars[0]=&quot;Saab&quot;; cars[1]=&quot;Volvo&quot;; cars[2]=&quot;BMW&quot;; 或者 (condensed array): var cars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 或者 (literal array): 实例 var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566}; 如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 这条语句： carname=&quot;Volvo&quot;; 将声明 window 的一个属性 carname。 非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。 javaScript 变量生命周期在它声明时初始化。 局部变量在函数执行完毕后销毁。 全局变量在页面关闭后销毁。 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变。4.对象的方法 你可以使用以下语法创建对象方法： methodName : function() { code lines } 你可以使用以下语法访问对象方法： objectName.methodName() 通常 fullName() 是作为 person 对象的一个方法， fullName 是作为一个属性。 有多种方式可以创建，使用和修改 JavaScript 对象。 同样也有多种方式用来创建，使用和修改属性和方法。5.事件（触发js函数） HTML 事件可以是浏览器行为，也可以是用户行为。 以下是 HTML 事件的实例： HTML 页面完成加载 HTML input 字段改变时 HTML 按钮被点击 常见的HTML事件 下面是一些常见的HTML事件的列表: 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 你可以使用索引位置来访问字符串中的每个字符： 实例 var character = carname[7]; onload 和 onunload 事件 onload 和 onunload 事件会在用户进入或离开页面时被触发。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie。 onchange 事件 onchange 事件常结合对输入字段的验证来使用。 下面是一个如何使用 onchange 的例子。当用户改变输入字段的内容时，会调用 upperCase() 函数。 实例 &lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt; onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 onmousedown、onmouseup 以及 onclick 事件 onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。6.语句 switch(n) { case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: 与 case 1 和 case 2 不同时执行的代码 } var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25}; for (x in person) // x 为属性名 { txt=txt + person[x]; }7.typeof 操作符 你可以使用 typeof 操作符来检测变量的数据类型。 实例 typeof &quot;John&quot; // 返回 string typeof 3.14 // 返回 number typeof false // 返回 boolean typeof [1,2,3,4] // 返回 object typeof {name:&apos;John&apos;, age:34} // 返回 objec8.null null是一个只有一个值的特殊类型。表示一个空对象引用。 你可以设置为 null 来清空对象: 实例 var person = null; // 值为 null(空), 但类型为对象 尝试一下 » 你可以设置为 undefined 来清空对象: 实例 var person = undefined; // 值为 undefined, 类型为 undefined9.undefined 在 JavaScript 中, undefined 是一个没有设置值的变量。 typeof 一个没有值的变量会返回 undefined。 实例 var person; // 值为 undefined(空), 类型是undefined 在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。10.数据类型 JavaScript 数据类型 在 JavaScript 中有 5 种不同的数据类型： string number boolean object function 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined NaN 的数据类型是 number 数组(Array)的数据类型是 object 日期(Date)的数据类型为 object null 的数据类型是 object 未定义变量的数据类型为 undefined 如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 typeof 来判断他们的类型，因为都是 返回 object。11.constructor 属性 constructor 属性返回所有 JavaScript 变量的构造函数。 实例 &quot;John&quot;.constructor // 返回函数 String() { [native code] } (3.14).constructor // 返回函数 Number() { [native code] } false.constructor // 返回函数 Boolean() { [native code] } [1,2,3,4].constructor // 返回函数 Array() { [native code] } {name:&apos;John&apos;, age:34}.constructor // 返回函数 Object() { [native code] } new Date().constructor // 返回函数 Date() { [native code] } function () {}.constructor // 返回函数 Function(){ [native code] }12.类型转化 将数字转换为字符串 全局方法 String() 可以将数字转换为字符串，或者同toString（） 该方法可用于任何类型的数字，字母，变量，表达式： 实例 String(x) // 将变量 x 转换为字符串并返回 String(123) // 将数字 123 转换为字符串并返回 String(100 + 23) // 将数字表达式转换为字符串并返回13.date 在 Date 方法 章节中，你可以查看更多关于日期转换为字符串的函数： 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。14.字符串转化成数字 将字符串转换为数字 全局方法 Number() 可以将字符串转换为数字。 字符串包含数字(如 &quot;3.14&quot;) 转换为数字 (如 3.14). 空字符串转换为 0。 其他的字符串会转换为 NaN (不是个数字)。 Number(&quot;3.14&quot;) // 返回 3.14 Number(&quot; &quot;) // 返回 0 Number(&quot;&quot;) // 返回 0 Number(&quot;99 88&quot;) // 返回 NaN 在 Number 方法 章节中，你可以查看到更多关于字符串转为数字的方法： 方法 描述 parseFloat() 解析一个字符串，并返回一个浮点数。 parseInt() 解析一个字符串，并返回一个整数。 一元运算符 + Operator + 可用于将变量转换为数字： 将布尔值转换为数字 全局方法 Number() 可将布尔值转换为数字。 Number(false) // 返回 0 Number(true) // 返回 1 将日期转换为数字 全局方法 Number() 可将日期转换为数字。 d = new Date(); Number(d) // 返回 1404568027739 日期方法 getTime() 也有相同的效果。 d = new Date(); d.getTime() // 返回 140456802773915.正则表达式 实例解析： /runoob/i 是一个正则表达式。 runoob 是一个正则表达式主体 (用于检索)。 i 是一个修饰符 (搜索不区分大小写)。 使用字符串方法 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 修饰符 可以在全局搜索中不区分大小写: 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 正则表达式模式 方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [0-9] 查找任何从 0 至 9 的数字。 (x|y) 查找任何以 | 分隔的选项。 元字符是拥有特殊含义的字符： 元字符 描述 \\d 查找数字。 \\s 查找空白字符。 \\b 匹配单词边界。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词: 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。16.JavaScript 变量提升 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 变量提升：函数声明和变量声明总是会被解释器悄悄地被&quot;提升&quot;到方法体的最顶部。17.约束 约束验证 HTML 输入属性 属性 描述 disabled 规定输入的元素不可用 max 规定输入元素的最大值 min 规定输入元素的最小值 pattern 规定输入元素值的模式 required 规定输入元素字段是必需的 type 规定输入元素的类型 完整列表，请查看 HTML 输入属性。 约束验证 CSS 伪类选择器 选择器 描述 :disabled 选取属性为 &quot;disabled&quot; 属性的 input 元素 :invalid 选取无效的 input 元素 :optional 选择没有&quot;required&quot;属性的 input 元素 :required 选择有&quot;required&quot;属性的 input 元素 :valid 选取有效值的 input 元素18.JSON JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组 JSON.parse() 用于将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串。19.Java Script void（0） href=&quot;#&quot;与href=&quot;javascript:void(0)&quot;的区别 # 包含了一个位置信息，默认的锚是#top 也就是网页的上端。 而javascript:void(0), 仅仅表示一个死链接。 在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。 如果你要定义一个死链接请使用 javascript:void(0) 。 void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行，如 void(alert(&quot;Wornning!&quot;))20.arguments 对象 JavaScript 函数有个内置的对象 arguments 对象。 argument 对象包含了函数调用的参数数组。 通过这种方式你可以很方便的找到最大的一个参数的值： 实例 x = findMax(1, 123, 500, 115, 44, 88); function findMax() { var i, max = arguments[0]; if(arguments.length &lt; 2) return max; for (i = 0; i &lt; arguments.length; i++) { if (arguments[i] &gt; max) { max = arguments[i]; } } return max; }参数也可以设置默认值 21.查找 HTML 元素 通常，通过 JavaScript，您需要操作 HTML 元素。 为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事： 通过 id 找到 HTML 元素 通过标签名找到 HTML 元素 通过类名找到 HTML 元素 通过 id 查找 HTML 元素 在 DOM 中查找 HTML 元素的最简单的方法，是通过使用元素的 id。 本例查找 id=&quot;intro&quot; 元素： 实例 var x=document.getElementById(&quot;intro&quot;); 如果找到该元素，则该方法将以对象（在 x 中）的形式返回该元素。 如果未找到该元素，则 x 将包含 null。 通过标签名查找 HTML 元素 本例查找 id=&quot;main&quot; 的元素，然后查找 id=&quot;main&quot; 元素中的所有 &lt;p&gt; 元素： 实例 var x=document.getElementById(&quot;main&quot;); var y=x.getElementsByTagName(&quot;p&quot;); 通过类名找到 HTML 元素 本例通过 getElementsByClassName 函数来查找 class=&quot;intro&quot; 的元素： 实例 var x=document.getElementsByClassName(&quot;intro&quot;); 改变 HTML 属性 如需改变 HTML 元素的属性，请使用这个语法： document.getElementById(id).attribute=新属性值 本例改变了 &lt;img&gt; 元素的 src 属性： 实例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt; &lt;script&gt; document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 改变 HTML 样式 如需改变 HTML 元素的样式，请使用这个语法： document.getElementById(id).style.property=新样式 控制文本是否显现 style.visibility=&apos;hidden&apos; style.visibility=&apos;visible&apos;22.监听器 addEventListener() 方法用于向指定元素添加事件句柄。 addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。 你可以向一个元素添加多个事件句柄。 你可以向同个元素添加多个同类型的事件句柄，如：两个 &quot;click&quot; 事件。 你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。 当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 你可以使用 removeEventListener() 方法来移除事件的监听。 element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 &quot;click&quot; 或 &quot;mousedown&quot;). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 事件冒泡或事件捕获？ 事件传递有两种方式：冒泡与捕获。 事件传递定义了元素事件触发的顺序。 如果你将 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 &quot;click&quot; 事件先被触发呢？ 在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p&gt; 元素的点击事件先触发，然后会触发 &lt;div&gt; 元素的点击事件。 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。 addEventListener() 方法可以指定 &quot;useCapture&quot; 参数来设置传递类型： addEventListener(event, function, useCapture); 默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。 实例 document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, myFunction, true); removeEventListener() 方法 removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄: 实例 element.removeEventListener(&quot;mousemove&quot;, myFunction);23.DOM元素节点 JavaScript HTML DOM 元素 (节点) 本章节介绍如何向文档中添加和移除元素(节点)。 创建新的 HTML 元素 (节点) - appendChild() 要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。 实例 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var node = document.createTextNode(&quot;这是一个新的段落。&quot;); para.appendChild(node); var element = document.getElementById(&quot;div1&quot;); element.appendChild(para); &lt;/script&gt; 尝试一下 » 实例解析 以下代码是用于创建 &lt;p&gt; 元素: var para = document.createElement(&quot;p&quot;); 为 &lt;p&gt; 元素创建一个新的文本节点： var node = document.createTextNode(&quot;这是一个新的段落。&quot;); 将文本节点添加到 &lt;p&gt; 元素中： para.appendChild(node); 最后，在一个已存在的元素中添加 p 元素。 查找已存在的元素： var element = document.getElementById(&quot;div1&quot;); 添加到已存在的元素中: element.appendChild(para); 创建新的 HTML 元素 (节点) - insertBefore() 以上的实例我们使用了 appendChild() 方法，它用于添加新元素到尾部。 如果我们需要将新元素添加到开始位置，可以使用 insertBefore() 方法: 实例 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var node = document.createTextNode(&quot;这是一个新的段落。&quot;); para.appendChild(node); var element = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p1&quot;); element.insertBefore(para, child); &lt;/script&gt; 尝试一下 » 移除已存在的元素 要移除一个元素，你需要知道该元素的父元素。 实例 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var parent = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p1&quot;); parent.removeChild(child); &lt;/script&gt; 尝试一下 » 注意：早期的 Internet Explorer 浏览器不支持 node.remove() 方法。 实例解析 HTML 文档中 &lt;div&gt; 元素包含两个子节点 (两个 &lt;p&gt; 元素): &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt; &lt;/div&gt; 查找 id=&quot;div1&quot; 的元素: var parent = document.getElementById(&quot;div1&quot;); 查找 id=&quot;p1&quot; 的 &lt;p&gt; 元素: var child = document.getElementById(&quot;p1&quot;); 从父元素中移除子节点： parent.removeChild(child); lamp 如果能够在不引用父元素的情况下删除某个元素，就太好了。 不过很遗憾。DOM 需要清楚您需要删除的元素，以及它的父元素。 以下代码是已知要查找的子元素，然后查找其父元素，再删除这个子元素（删除节点必须知道父节点）： var child = document.getElementById(&quot;p1&quot;); child.parentNode.removeChild(child); 替换 HTML 元素 - replaceChild() 我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。 实例 &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var para = document.createElement(&quot;p&quot;); var node = document.createTextNode(&quot;这是一个新的段落。&quot;); para.appendChild(node); var parent = document.getElementById(&quot;div1&quot;); var child = document.getElementById(&quot;p1&quot;); parent.replaceChild(para, child); &lt;/script&gt; JavaScript HTML DOM 集合(Collection) 本章节介绍如何向文档中添加和移除元素(节点)。 HTMLCollection 对象 getElementsByTagName() 方法返回 HTMLCollection 对象。 HTMLCollection 对象类似包含 HTML 元素的一个数组。 以下代码获取文档所有的 &lt;p&gt; 元素： 实例 var x = document.getElementsByTagName(&quot;p&quot;); 集合中的元素可以通过索引(以 0 为起始位置)来访问。 访问第二个 &lt;p&gt; 元素可以是以下代码: y = x[1]; 尝试一下 » HTMLCollection 对象 length 属性 HTMLCollection 对象的 length 属性定义了集合中元素的数量。 实例 var myCollection = document.getElementsByTagName(&quot;p&quot;); document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length; 尝试一下 » 实例解析 获取 &lt;p&gt; 元素的集合： var myCollection = document.getElementsByTagName(&quot;p&quot;); 显示集合元素个数： document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length; 集合 length 属性常用于遍历集合中的元素。 实例 修改所有 &lt;p&gt; 元素的背景颜色: var myCollection = document.getElementsByTagName(&quot;p&quot;); var i; for (i = 0; i &lt; myCollection.length; i++) { myCollection[i].style.backgroundColor = &quot;red&quot;; } 尝试一下 » 注意 HTMLCollection 不是一个数组！ HTMLCollection 看起来可能是一个数组，但其实不是。 你可以像数组一样，使用索引来获取元素。 HTMLCollection 无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。","categories":[],"tags":[]},{"title":"bootstrap 学习记录","slug":"bootstrap-学习记录","date":"2019-08-06T03:33:36.000Z","updated":"2019-09-27T02:43:18.118Z","comments":true,"path":"2019/08/06/bootstrap-学习记录/","link":"","permalink":"https://zhj1988.github.io/2019/08/06/bootstrap-学习记录/","excerpt":"","text":"等等","categories":[],"tags":[]},{"title":"SpringBoot结构分层解析 ","slug":"SpringBoot结构分层解析","date":"2019-07-24T01:50:02.000Z","updated":"2019-09-27T02:44:05.925Z","comments":true,"path":"2019/07/24/SpringBoot结构分层解析/","link":"","permalink":"https://zhj1988.github.io/2019/07/24/SpringBoot结构分层解析/","excerpt":"简介：最近使用springBoot写项目，springBoot的层次分层跟之前学习不太一样，百度得到的答案杂七杂八，最后在github上找一个例子，依样画葫芦之后总算运算成功，特此记录一下","text":"简介：最近使用springBoot写项目，springBoot的层次分层跟之前学习不太一样，百度得到的答案杂七杂八，最后在github上找一个例子，依样画葫芦之后总算运算成功，特此记录一下 springBoot项目的结构分层 总共分成五个文件夹 controller configuration bean（entity） dao（mapper） service 下面对每个层次进行分析 一、controller控制层 使用@Controller注解标志控制类主要负责写url，对与前端数据进行交互@AutowiredUserDao userdao现实Dao层接口之后使用user.xx 方法与数据库交互 二、configuration配置层 使用@Configuration注解标志配置类本层编写spring MVC / Mybatis 配置的一些文件，再使用@Bean添加到容器中本层如果全部自动配置，使用注解，这一层可以不用编写 三、bean实体类 编写数据库表映射的类，如果使用hibernate，使用@Entity标志类，@Table标志表名，@id标志主键 ，@Columns标志列名，自动在数据库中建表不要忘记创建set and get 方法 四、dao层 本层为接口1、如果使用@entity标志类，本层可以直接编写方法，调用实体类中的方法如 User user.getOne(id); 2、如果使用mybatis，全注解方式 @Repository @Mapper public interface UserDao { //通过手机号码找到登录密码 @Select(&quot;select user_password from user where user_phone = #{userPhone}&quot;) String getUserPassword(String userPhone);3、如果使用mybatis，配置文件方式首先需要在Configuration层，编写相应的配置文类，再@Bean添加到容器中在application.xml/application.yml编写 mybatis: config-location: classpath:mybatis/myabtis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml之后可以在uao接口编写相应的方法 五、service业务逻辑层 此层分层两个部分，service接口和serviceImpl实现类 service接口 public interface UserService { String getUserPassword(String userPhone); void insertUser(User uer); }serviceImpl实现类 @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public String getUserPassword(String userPhone) { return userDao.getUserPassword(userPhone); } @Override public void insertUser(User user) { userDao.insertUser(user); } }Sring Boot 使用过程中碰到的知识点一、注解篇1.@CrossOrigin：标志接口类，指明改接口允许跨域请求（用于前后端交互时候，前段项目不在同一服务器中） 2.@RestMapping：@ResponseBody 跟 @RequestMapping(“”)合二为一的注解 3.@Options(useGeneratedKeys = true,keyProperty = “id”) @Insert用于插入语句后，将数据库中自增主键的id 返回给插入对象 4.@SuppressWarnings注解允许您选择性地取消特定代码段（即，类或方法）中的警告。其中的想法是当您看到警告时，您将调查它，如果您确定它不是问题，您就可以添加一个@SuppressWarnings注解，以使您不会再看到警告。虽然它听起来似乎会屏蔽潜在的错误，但实际上它将提高代码安全性，因为它将防止您对警告无动于衷 — 您看到的每一个警告都将值得注意。@SuppressWarnings(“all”)忽略以下所有警告 5.@Transactional注解的特性 1)service类标签(一般不建议在接口上)上添加@Transactional，可以将整个类纳入spring事务管理，在每个业务方法执行时都会开启一个事务，不过这些事务采用相同的管理方式。 2)@Transactional 注解只能应用到 public 可见度的方法上。 如果应用在protected、private或者 package可见度的方法上，也不会报错，不过事务设置不会起作用。 3) 默认情况下，spring会对unchecked异常进行事务回滚；如果是checked异常则不回滚。辣么什么是checked异常，什么是unchecked异常？ java里面将派生于Error或者RuntimeException（比如空指针，1/0）的异常称为unchecked异常，其他继承自java.lang.Exception得异常统称为Checked Exception，如IOException、TimeoutException等再通俗一点：你写代码出现的空指针等异常，会被回滚，文件读写，网络出问题，spring就没法回滚了。 4)只读事务：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)只读标志只在事务启动时应用，否则即使配置也会被忽略。启动事务会增加线程开销，数据库因共享读取而锁定(具体跟数据库类型和事务隔离级别有关)。通常情况下，仅是读取数据时，不必设置只读事务而增加额外的系统开销。","categories":[],"tags":[]},{"title":"sql语句知识汇总","slug":"sql语句知识汇总","date":"2019-07-24T01:48:54.000Z","updated":"2019-09-27T02:44:05.197Z","comments":true,"path":"2019/07/24/sql语句知识汇总/","link":"","permalink":"https://zhj1988.github.io/2019/07/24/sql语句知识汇总/","excerpt":"简介：mysql上的sql语句一些简单的汇总，同时记录学习过程遇到的sql语句","text":"简介：mysql上的sql语句一些简单的汇总，同时记录学习过程遇到的sql语句 一、 数据库基本操作1、说明：创建数据库 CREATE DATABASE database-name 2、说明：删除数据库 drop database dbname 3、说明：备份sql server — 创建 备份数据的 device USE master EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\\mssql7backup\\MyNwind_1.dat’ — 开始 备份 BACKUP DATABASE pubs TO testBack 4、说明：创建新表 create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..) 根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表) B：create table tab_new as select col1,col2… from tab_old definition only 5、说明：删除新表 drop table tabname 6、说明：增加一个列 Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 7、说明：添加主键： Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) 8、说明：创建索引：create [unique] index idxname on tabname(col….) 删除索引：drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 9、说明：创建视图：create view viewname as select statement 删除视图：drop view viewname 10、说明：几个简单的基本的sql语句 选择：select * from table1 where 范围 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料! 排序：select * from table1 order by field1,field2 [desc] 总数：select count as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 11、说明：几个高级查询运算词 A： UNION 运算符 UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 12、说明：使用外连接 A、left (outer) join： 左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c B：right (outer) join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 C：full/cross (outer) join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 13、分组:Group by: 一张表，一旦分组 完成后，查询后只能得到组相关的信息。 组相关的信息：(统计信息) count,sum,max,min,avg 分组的标准) 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起; 14、对数据库进行操作： 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 15.如何修改数据库的名称: sp_renamedb ‘old_name’, ‘new_name’ 16、创建外键 create table course ( cno varchar(20) not null , cname varchar(20) not null, tno varchar(20) not null, foreign key(tno) references teacher(tno) );二、数据库优化如何进行SQL优化？ （1）选择正确的存储引擎以 MySQL为例，包括有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT() 这类的计算是超快无比的。InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。（2）优化字段的数据类型记住一个原则，越小的列会越快。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。（3）为搜索字段添加索引索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。(4)避免使用Select*从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。即使你要查询数据表的所有字段，也尽量不要用**通配符，善用内置提供的字段排除定义也许能给带来更多的便利。(5)使用 ENUM 而不是 VARCHARENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。例如，性别、民族、部门和状态之类的这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。(6)尽可能的使用 NOT NULL除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。 NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。(7)固定长度的表会更快如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。 三、其他操作1.自增主键重置ALTER TABLE babyTeacher.user AUTO_INCREMENT = 1; 2.order by RAND() 随机抽取数据 优化该sql SELECT * FROM table AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(id) FROM table)-(SELECT MIN(id) FROM table))+(SELECT MIN(id) FROM table)) AS id) AS t2WHERE t1.id &gt;= t2.idORDER BY t1.id LIMIT 1;","categories":[],"tags":[]},{"title":"Struts2总结与体会","slug":"Struts总结与体会","date":"2019-07-14T12:30:19.000Z","updated":"2019-09-27T02:44:04.423Z","comments":true,"path":"2019/07/14/Struts总结与体会/","link":"","permalink":"https://zhj1988.github.io/2019/07/14/Struts总结与体会/","excerpt":"简介：记录一些学习Struct2过程中的知识","text":"简介：记录一些学习Struct2过程中的知识 1.配置核心过滤器在web.xml中配置 &lt;filter&gt; &lt;filter-name&gt;abc&lt;/filter-name&gt; &lt;filter-class&gt;&quot;过滤器类&quot;&lt;/filter-name&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filer-name&gt;abc&lt;/filer-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--所有路径请求都可以被捕捉到--&gt; &lt;/filter-mapping&gt;2.src/struct.xml（配置文件）管理Action ，通过包管理 &lt;structs&gt; &lt;package name=&quot;hello&quot; extends=&quot;structs-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;前端请求路径，ex：前端hello.action；此处hello&quot; class=&quot;类路径&quot;&gt; &lt;!--配置页面跳转--&gt; &lt;result name=&quot;sucesss&quot;&gt;/demo/demo.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/structs&gt;3.struct2执行流程：1）前端过滤器2）执行过滤器中的一组拦截器(拦截器实现部分功能)3）找到struct.xml中的Action4）执行目标的Action，根据Action的返回值进行页面挑战定义方法Action :public String execute（）{return “success”}//公有类，返回类型为String，无参数 4.struts2配置文件1）package配置 ：管理Action配置name:包的名称可以随便定，保证唯一extends：通常继承引入jar包中的structs-default.xmlnamespace：名称空间,与Action name 共同决定访问路径{带名称的名称空间：”/a”; 根名称空间：”/“; 默认名称空间:””}abstract：抽象的，用于被其他包继承 2)Action配置：name：与namespace共同决定访问路径class：Action类的全路径method：执行Action中的哪个方法，默认值为executeconverter：自定义类型转换器 3）常量配置：（default-properties）修改方法：struct.xml：; struct.properties(src/,自定义，只能用于修改常量，不能用于配置)；在web.xml中修改过滤器： &lt;filter&gt; &lt;init-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 4）分模块开发include标签：在java包中，自定义自己的struct_demo1.xml，在总的struct.xml中： 5.Ation的写法1）Action类是POJO类：简单java类，没有继承类没有接口2）Action实现一个Action的接口：提供五个常量（五个逻辑视图的名称） INPUT：表单校验的时候出错3）Action类继承ActionSupport类：提供了一系列数据校验，国际化等一系列操作的方法 6.Action的访问1）通过method设置 2）通过配置符设置：前端访问路径要统一格式，ex：User_find/User_update &lt;action name=&quot;User_*&quot; class=&quot;类路径&quot; method=&quot;{1}&quot;&gt; &lt;!--更抽象的方法--&gt; &lt;action name=&quot;*_*&quot; class=&quot;类路径.{1}&quot; method=&quot;{2}&quot;&gt;3)动态方法访问开启动态方法访问： struct.xml：&lt;constant name=&quot;DynamicMethodInvocation&quot; value=&quot;true&quot;/&gt;;前端编写访问路径：User！find.Action / User！update.Action 7.Struct的Servlet的API访问a）完全解耦合方式使用ActionContext接收前端数据 ActionContext context = ActionContext.getContext（）； Map&lt;String,Object&gt;map = context.getParameters(); context.put(&quot;reqName&quot;,&quot;reqValue&quot;);//相当于request.setAttribute（）; context.getSession.put(&quot;reqName&quot;,&quot;reqValue&quot;);//相当于session.setAttribute（）; context.getApplication.put(&quot;reqName&quot;,&quot;reqValue&quot;);//相当于application.setAttribute（）;这种方式只能获得代表request、session、application的数据的Map集合，不能操作这些对象的本身的方法 b)使用Servlet的原生方式 HttpServletRequest request = ServletActionContext.getRequest(); Map&lt;String,Object&gt;map = request.getParameters(); request.setAttribute(&quot;reqName&quot;,&quot;reqValue&quot;);//request.setAttribute（）; request.getSession.setAttribute(&quot;sessName&quot;,&quot;sessValue&quot;);//session.setAttribute（）; ServletActionContext().setAttribute(&quot;appName&quot;,&quot;appValue&quot;);//application.setAttribute（）; 可以操作域对象的数据，同时也可以获得对象的方法。 c）接口注入的方式 //添加接口 extends ActionSupport implements ServletRequestAware,ServletContextAware //添加属性 private HttpServletRequest request; private ServletContext context; //接口实现两个方法，赋值给对象属性 public void setServletRequest（HttpServletRequest request）{ this.request = request；} Servlet是单例的，多个程序访问同一个Servlet只会创建一个Servlet的实例。Action是多例的，一次请求，创建一个Action的实例（不会出现线程安全的问题） 8.Struct的结果页面配置全局结果页面配置：在包中配置一次，在这个包的所有action只要返回这个值，都能跳转这个页面 &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;/demo.jsp&lt;/result&gt; &lt;/global-results&gt;局部结果页面配置：针对当前的action有效,优先级大于全局 &lt;action name=&quot;前端请求路径&quot; class=&quot;类路径&quot;&gt; &lt;!--配置页面跳转--&gt; &lt;result name=&quot;sucesss&quot;&gt;/demo/demo.jsp&lt;/result&gt; &lt;/action&gt;9.result标签配置1）name：逻辑视图的名称，默认success2）type：页面跳转的类型a）dispatch：默认值，请求转发 （Action到jsp）b）redirect：重定向（Action到jsp）c）chain：转发（Action到Action）d）redirectAction：重定向（Action到Action）d）stream：struct2提供文件下载功能 10.struct的数据封装1）属性驱动：提供属性set的方法Action，添加user的属性（name，password），并提供相应的set，get方法，在execute方法中，new user，然后set赋值（用于属性较少的时候） 2）属性驱动：页面提供表达式的方法Action中，添加user，提供相应的set，get方法；前端相应修改为user.name，user.password（拦截器完成数据封装，需要有get方法，如果没有get方法，拦截器为每个一个属性创建对象，返回一个对象只包含一个属性值）可以同时向多个对象封装 3）模型驱动：采用模型驱动方法 implements ModelDriver&lt;User&gt;{ private User user new User(); public User getModel(){ return null; } } 只能同时向一个对象中封装数据 11.关于INPUT逻辑视图的配置在某些拦截器中使用，输入数据出错 &lt;result name=&quot;INPUT&quot;&gt;/error.jsp&lt;/result&gt; 12.复杂数据类型封装1）List 封装 :2）map封装： 13.OGNL对象图导航语言； 可以调用对象的方法，获得struct2的值栈的数据 1）使用要素：a）表达式：做什么b）根对象：对谁操作c）Context：操作环境 2）Ognl的使用a）Ognl调用对象的方法 OgnlContext context = new OgnlContext（）； Object root= Context.getRoot（）； Object obj =Ognl.getValue（&quot;&apos;hello&apos;.length&quot;,context,root） b）Ognl访问对象的静态方法：@类名@方法名 OgnlContext context = new OgnlContext（）； Object root= Context.getRoot（）； Object obj =Ognl.getValue（&quot;@java.lang.Math@random()&quot;,context,root）c)获取root对象中值 OgnlContext context = new OgnlContext（）； context.setRoot（new User(&quot;a&quot;,&quot;123&quot;)); Object root= Context.getRoot（）； Object username =Ognl.getValue(&quot;username&quot;,context,root); Object username =Ognl.getValue(&quot;password&quot;,context,root);d)获取Context数据： OgnlContext context = new OgnlContext（）； Object root= Context.getRoot（）； context.put（&quot;name&quot;,&quot;张三&quot;） Object name =Ognl.getValue(&quot;#name&quot;,context,root);关键在#号 3）在jsp页面中，添加struct标签&lt;s:property value=””/&gt; 14.ValueStack值栈1）容器，structs的一个接口，OgnlValueStack的实现类，客户端发送请求之后，struct架构会创建一个Action实例，同时创建一个OgnlValueStack值栈的实例类，将请求Action的参数封装为对象存储到值栈中，通过Ognl表达式读取值栈中对象属性名2)获取值栈对象：ValueStack valuestack =ActionContext.getContext.getValueStack（）；两个主要区域：root：ArrayList，放置对象Object ； context：map，web常用对象的引用，ex：root/request/session/application/parameters/attr3)值栈与ActionContext的关系ActionContext对象中有 valueStack的引用，所以能够访问Servlet的API4)获得值栈ValueStack通过ActionContext.getContext.getValueStack ；通过request得到 ServletActionContext.getRequest（）.getAttribute（ServletActionContext.STRUTS_VALUESTACK_KEY）；5)值栈操作存入数据：Action提供属性的get方法：使用ValueStack本身的方法：valueStack.push（user）；//入栈valueStack.set（”key”,”value”）;//创建一个map，存入值栈中，如果没有设置get方法，无法显示，但是能够获取到数据6）Ognl特殊字符# ： 获取context的数据；构建map集合%：$ ：","categories":[],"tags":[]},{"title":"maven学习与总结","slug":"maven学习与总结","date":"2019-07-13T09:29:54.000Z","updated":"2019-07-18T01:35:38.402Z","comments":true,"path":"2019/07/13/maven学习与总结/","link":"","permalink":"https://zhj1988.github.io/2019/07/13/maven学习与总结/","excerpt":"简介：整理一下学习到maven的琐碎知识点","text":"简介：整理一下学习到maven的琐碎知识点 maven可以集中管理jar包，在pom.xml添加依赖，可以直接获取jar包，把项目当成对象管理依赖包括的部分： &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; groupId：包名称，项目由哪个组织开发 artifactId：一般是项目名称，类似于姓名 version：jar包版本号 maven可以代理，进行一步构建：编译，测试，运行，打包，安装；在setting修改，添加本地仓库，保证无联网的状态下也可以下载jar包；maven标准的目录结构 src：main{java，resources，webapp{WEB-INF{web.xml} } } test{java，resources} pom.xml maven命令： clean ：删除target目录下所有内容 compile：编译，java文件编译输出到target目录下的class文件中 test：执行src/test/java 测试类 package：java工程打包成jar包，web工程打包成war包 install：把maven打包成jar包或者war包，发布到本地仓库 maven生命周期：clean lifecycle：在项目建立之前做清理工作default lifecycle：编译，测试，打包部署site lifecycle：生成项目，站点，发布站点 &lt;scope&gt; &lt;/scope&gt; compile：编译provided：编译的时候需要，打包的时候不需要，即最终运行不用（例如servlet-api，tomcat本身还有jsp jar包，不需要添加依赖，但是不添加依赖却报错）runtime：运行的时候需要，编译不需要（类似于jdbc）test：测试编译和测试运行时候需要，注解@Test，使用junit jar包system：范围依赖于provided类似，需要制定systempath磁盘路径，此依赖不推荐使用 使用maven：父工程（maven-project），子工程（maven-Module：dao，service，web三个子工程），具有依赖的传递性；子工程的pom.xml添加其他子工程的依赖，相当于引入jar包，service依赖dao，web依赖service（由于依赖的传递性，到jar也会被引入进来）；依赖的传递也是有局限性的，使用域的范围（例如junit，依赖范围为test，所以不能传递）；解决依赖冲突的方法：exclusion标签，删除冲突jar；依赖管理原则 ：第一声明者优先，即不同版本的jar，谁现在pom.xml中优先声明，谁优先使用；路径近者优先 maven版本的锁定：在父工程，pomml中 用标签dependencyManagement，添加之后，子工程使用标签中相关jar包时，会有锁的标签； maven定义版本常量: &lt;properties&gt; &lt;spring.version&gt;4.2&lt;/spring.version&gt; &lt;/properties&gt; &lt;!--下面依赖中的版本号--&gt; &lt;version&gt;${spring.version}&lt;version&gt;方便统一管理","categories":[],"tags":[]},{"title":"Spring MVC入门介绍","slug":"Spring MVC入门介绍","date":"2019-07-10T06:44:09.000Z","updated":"2019-07-16T10:40:47.376Z","comments":true,"path":"2019/07/10/Spring MVC入门介绍/","link":"","permalink":"https://zhj1988.github.io/2019/07/10/Spring MVC入门介绍/","excerpt":"简介：Spring MVC 基于MVC架构模式的轻量级web框架，属于Web-MVC处理层框架，目的是将web开发模块化，分为三个层次；M，model：开发数据模型层，封装输入输出的用户信息；V，view：响应视图层，在请求结果显示阶段，跳转的结果网页；C，controller：控制层，负责前台与后台的交互；Spring MVC基于方法开发，支持单例开发","text":"简介：Spring MVC 基于MVC架构模式的轻量级web框架，属于Web-MVC处理层框架，目的是将web开发模块化，分为三个层次；M，model：开发数据模型层，封装输入输出的用户信息；V，view：响应视图层，在请求结果显示阶段，跳转的结果网页；C，controller：控制层，负责前台与后台的交互；Spring MVC基于方法开发，支持单例开发 第一部分Spring mvc的工作原理第一步 用户发送请求，request请求，前段控制器DispatcherServlet处理；第二步 前端控制器请求处理映射器HandlerMapping查找Handler，也可以依据注解或者XML配置去查找；第三步 处理器映射器找到Handler（其中可能包含若干个Interceptor拦截器），返回给前端控制器；第四步 前端控制器请求处理器适配器（HandlerAdapter）去执行相应的Handler（也称呼为Controller）；第五步 处理器适配器执行Handler；第六步 Handler执行完返回一个ModelAndView对象给处理器适配器；第七步 处理器适配器将第六步返回的数据在传送给前端控制器；第八步 前端控制器接收到ModelAndView后，请求视图解析器ViewResolver对视图进行解析；第九步 视图解析器根据ViewResolver信息匹配到相应的视图结果，反馈给前端控制器；第十步 前端控制器收到View视图后进行视图渲染，将Model中的模型数据填充到View视图中的request域中，生成最终的视图；第十一步 前端控制器返回结果给用户 第二部分各部分组件介绍 前端控制器 处理器映射器：根据请求的url，通过注解或者xml配置，寻找匹配的Handler信息 处理器适配器：根据映射器找到处理器信息，按照特定规则执行下那个关的处理器 处理器：执行相关的请求处理逻辑，返回ModelAndView 视图解析器： 视图：本身是一个接口，实现类支持不同的view类型 知识点：1.在WebRoot文件夹下的web.xml文件中添加Spring MVC的前端控制器DispatcherServlet，用于拦截url请求 2.核心配置文件springmvc.xml：添加xml版本声明和一个包含spring标签声明规则的标签对。 3.前端控制器DispatcherServlet收到Handler返回数据model和视图view之后，配置视图解析器ViewResolver（XMLViewResolver，ResourceBundleViewResolver，InternalResourceViewResolver）根据Handler方法执行之后返回ModelAndView中的视图的具体位置，来加载相应的界面并绑定反馈数据 4.springmvc.xml中添加HandlerMapping(处理器映射器)寻找相关的Handler对象，返回控制器Handler的执行链，无论哪一种映射器都实现了HandlerMapping接口（BeanNameHandlerMapping处理映射器，将bean的name作为url进行查找，即在springmvc.xml中配置一个可以被url映射的Handler的bean，供处理器映射器查找，ex：） 5.springmvc.xml中添加HandlerAdapter(处理器适配器)调用自己的Handle，（HttpRequestHandlerAdapter/SimpleControllerHandlerAdapter/AnnotationMethodHandlerAdapter）无论哪一种适配器都实现了HandlerAdapter接口，SimpleControllerHandlerAdapter适配器支持所有实现Controller接口的Handler控制器 6.Handler处理器：利用java反射机制去执行具体的Controller方法并获得ModelAndView视图对象；在包创建类， 7.Handler处理器与视图 第三部分处理器映射器和适配器（一）非注解的处理器映射器和映射器1 非注解的处理器映射器（可配置，interceptors拦截器和Handler处理器） 1）BeanNameUrlHandlerMapping:将beanname作为url进行查找，需要在配置Handler时指定beanname（url），在springmv.xml中配置 2）SimpleUrlHandlerMapping：通过内部参数配置请求的url和Handler的映射关系&lt;bean id=&quot;urlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;interceptors&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;/someCheckInterceptor1/&gt; &lt;ref bean=&quot;/someCheckInterceptor1/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;/queryFruits_test1.action&quot;&gt;fruitsController&lt;/prop&gt; &lt;prop key=&quot;/queryFruits_test2.action&quot;&gt;fruitsController&lt;/prop&gt; &lt;prop key=&quot;/queryFruits_test3.action&quot;&gt;fruitsController2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--添加Handler的url--&gt; &lt;bean id=&quot;fruitsController&quot; class=&quot;cn.com.mvc.controller.FruitsControllerTest&quot; /&gt; &lt;bean id=&quot;fruitsController2&quot; class=&quot;cn.com.mvc.controller.FruitsControllerTest2&quot; /&gt;a.interceptors，拦截器b.mapping：key：xx.action -&gt; Controller url请求映射到Controller控制器 3）ControllerClassNameHandlerMapping:使用CoC惯例优先原则的方式来处理请求，对普通的Controller，其类名”xxxController”映射到”/xxx*”的请求URL；对于MultiActionController类型的Controller，ControllerClassNameHandlerMapping会把类名”xxxController”以及类名中的方法”yyy”映射到”xxx/yyy.action”,ex: &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt; 2 非注解的处理器适配器 1)SimpleControllerHandlerAdapter:SimpleControllerHandlerAdapter适配器支持所有实现Controller接口的Handler控制器 2)HttpRequestHandlerAdapter:在Spring MVC配置文件中修改相应的bean标签：&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt; ， Handler实现HttpRequestHandler接口，使用这种Handler的开发方式，方便开发者获取request的相关http请求信息，以及设置返回对象response的一些参数 （二）注解的处理器映射器和适配器（主流配置方法）如果在核心配置文件中（springmvc.xml）默认配置文件中有DefaultAnnotationHandlerMapping，AnnotationMethodHandlerAdapter等注解处理器映射器和适配器注解的处理器映射器和适配器两种配置方式： 第一种配置方式：和非注解的处理器映射器和适配器一样，在核心配置文件中声明相关的bean，ex：&lt;!-- 注解映射器 --&gt; &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; --&gt; &lt;!-- 注解适配器 --&gt; &lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; --&gt;不使用annotation-driven标签配置，必须保证基于注解的处理器映射器和适配器成对配置第二种配置方式：使用mvc:annotation-driven/标签配置，annotation-driven标会自动注册处理器映射器和处理器适配器，不需要在xml中配置任何信息，也不需要实现任何接口，只需要作为Handler处理的类中添加相应的注解即可，ex： &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; validator=&quot;validator&quot;&gt; &lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt;使用在类上@Controller 标识它是一个控制器，在方法上@RequestMapping注解信息，指定一个URL与该方法绑定。 为了让注解的处理器映射器和适配器找到注解的Handler，有两种配置方式：第一种在核心配置文件中声明相关的bean信息即可：&lt;bean class=&quot;类路径&quot;&gt;&lt;/bean&gt;第二种，使用扫描配置，对某一个包下的所有类进行扫描，找出所有使用的@Controller注解的Handler控制器类: &lt;context:component-scan base-package=&quot;cn.com.mvc.controller&quot;&gt;&lt;/context:component-scan&gt; 第四部分前端控制器和视图解析器（一）前端控制器DispatcherServlet：在web.xml中添加： springmvc .aciton 所有以.action结尾的请求都会去寻找springmvc的servlet配置：&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;int-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/int-param&gt;&lt;/servlet&gt;DispatcherServlet顶级父类HttpServlet类中方法，doGet（）跟都Post（），而其核心功能有doService跟doDispatch实现：doService 处理request请求（doPost跟doGet）；doDispatch处理拦截，转发请求调用处理器获得结果，并绘制结果视图*前端控制器处理请求步骤**：第一步通过servlet类型的父类处理，调用doService在request中设置一些必要的参数，然后调用doDispatch第二步在doDispatch中，先检测request是否包含多媒体类型，在转化成processedRequest对象，之后比较request，若为true，删除processedRequest第三步调用处理器映射器查找Handler，调用getHandler获取相关的处理器对象，即在getHandler中，利用HandlerMapping通过request获取一个包含Handler本身和前后拦截器interceptor的处理器执行链HandlerExecutionChain对象第四步通过处理器执行类对象获取具体的Handler处理器对象，使用getHandlerAdapter方法获取处理器适配器对象第五步调用HandlerAdapter对象的handle方法，将request对象，以及Handler处理器本身作为参数传入，返回ModelAndView对象第六步获得ModelAndView对象后，进行视图渲染，model数据填充到request域中，在processDispatchResult方法中render方法，将ModelAndView对象以及request，response对象作为参数传入，把model对象中数据遍历，分为key和value，设置在request的attribute域中 （二）视图解析器ViewResolve把一个逻辑上的视图名称解析为一个真正的视图，即为具体的View对象1.UrlBasedViewResolver： prefix属性指定视图资源所在路径的前缀信息，ex：prefix”/WEB-INF/page”suffix属性指定视图所在资源路径的后缀信息,ex:”.jsp”view视图名称：”/user/login”加载路径：/WEB-INF/page/user/login.jsp UrlBasedViewResolver支持前缀“redirect：”重定向：“forward：”内部跳转： 在springmvc.xml中配置： &lt;bean class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.InternalResourceView&quot;/&gt; &lt;/bean&gt;2.InternalResourceViewResolver： 继承了UrlBasedViewResolver，视图名称自动解析成InternalResourceView对象类型，ex： &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 第五部分Handler处理器（一）Controller与RequestMapping注解的配置 &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; validator=&quot;validator&quot;&gt; &lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt;mvc:annotation-driven标签表明，处理器Handler类型要符合annotation-driven指定的HandMapping跟HandlerAdapter，Spring3.1之后的版本为RequestMappingHandMapping 跟RequestMappingHandlerAdapter当使用@Controller注解配置一个类时候，告诉SpringMVC该类为一个Handler控制器类，配置了 &lt;context:component-scan base-package=&quot;cn.com.mvc.controller&quot;&gt;&lt;/context:component-scan&gt; Spring初始化时候，该controller类会被扫描作为Handler来加载 @Controller注解的类中，标注了@RequestMapping注解的方法，表明该方法是一个处理前端请求的方法，器value = “/test” 都是相对于web应用的根目录的相对路径 @RequestMapping，默认数据为value，即@RequestMapping（”/test”）等价于 @RequestMapping(value=”/test”),@RequestMapping中还包含了限定请求方法（method=RequestMethod.GET），请求参数(param=”username”)，请求头（headers=”Content-Type：text/html；charset=UTF-8”） （二）参数绑定将用户请求的key/value数据绑定到Controller处理器方法形参上 在方法参数中，加入HttpServletRequest，HttpServletrResponse,HttpSession,Model，ModelMap,ex:@RequestMapping（”/test”）public void method(Model model，Integer id){} 使用@RequestParam方法时，要求形参与传入参数名称一样，形参采用驼峰命名，ex：@RequestMapping（”/test”）public void method(Model model，@RequestParam(value=”user_id”)Integer user_Id){} @RequestParam,使用空校验时候，required属性为true，ex：@RequestMapping（”/test”）public void method(Model model，@RequestParam(value=”user_id”,required=true) Integer user_Id){} @RequestParam,使用默认值时候，加上defaultValue属性 包装类型参数绑定，ex：@RequestMapping（”/test”）public void method(Model model，User user){ … model.addAttribute（”userlist”,userlist）;} 集合类型参数绑定，使用name相同的数组类型形参接收，ex：1）数组类型：@RequestMapping（”/test”）public void method(Model model，int[] fids)2）List类型请求参数：使用集合名[下标].属性3）Map类型请求参数：Mao名[‘key值’]，String key=Map.keySet() , Map.get(key) 第六部分Validation校验（一）Bean Validation数据校验在核心配置文件中，添加Validator属性，指定validator值，并添加配置 ，ex： &lt;mvc:annotation-driven conversion-service=”conversionService” validator=”validator”&gt; &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt; &lt;!-- 校验器--&gt; &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验的错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt; &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 校验错误信息配置文件 --&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;!-- 资源文件名--&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:ProductValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot; /&gt; &lt;/bean&gt;1.providerClass，校验器提供类:org.hibernate.validator.HibernateValidator2.validationMessageSource校验器使用的资源文件，在文件中配置校验的错误信息3.bean id=”messageSource”自定义的校验资源文件，在springmvc中添加4.校正类型@Size（min =，max=，message=”{报错信息}”）;@NotEmpty(message=”{报错信息}”)ex：@RequestMapping（”/test”）public void method(Model model，@Validated User user，BindingResult bindingResult ){ }@Validated 与 BindingResult 成对出现，顺序固定5.将错误传到页面 model.addAttribute（”allErrors”,allErrors） （二）分组校验当javabean被不同的Controller调用的时候，有些需要Validation校验有些不用，这个时候就需要分组校验了1.新建一个接口public interface group1{}2.在实体类中校验分配给不同的组javabean:public class User{@Size（min =，max=，message=”{user.name.length.error}”，groups={group1.class}）;private String name;} 测试类中：public void method(Model model，@Validated（value=”group1.class”） User user，BindingResult bindingResult ){ }3.validator 接口实现1）编写一个实现了validator接口的实现类；2）测试类中，首先建立@initBinder 方法为DataBinder对象设置Validator校验对象，当调用下面方法形参中的有BindingResult参数时候，BindingResult对象将DataBinder中Validator的校验结果对象封装到自己的Errors对象集合中，BindingResult对象 Errors属性通过器getErrors（）方法获得校正错误信息，hasErrors（）方法获得是否有校正错误信息补充：Errors集合对象，为一个List,使用getcode(),getDefaultMessage()获得相关属性（String）；可以使用@valid标准需要检验的参数，spring才会对其检验 第七部分异常处理和拦截器（一）全局异常处理器 SpringMVC中有一个全局异常处理器，service，DAO，Controller层出现异常throws Exception的形式向上抛出，最后由前端控制器统一交给全局异常处理器处理 对于预期的异常，通常自定义异常类处理，将异常存储在自定义异常类中，如message属性，最后全局异常处理器处理该异常 自定义异常类UserException(继承Exception) -&gt; 全局异常类(UserExceptionResolver)实现HandlerExceptionResolver接口接口实现了resolverException方法，输入参数(Object handler,Exception ex), 返回值为ModelAndView ,通过这个返回值来设置异常时显示的页面；在全局异常处理器中，如果没有UserException定义的错误，输出message信息”未知错误”，最后都需要ModelAndView.addObject（”message”,message） （二）拦截器 interceptor拦截器，用于请求的预处理和后处理 继承或实现HandlerInterception接口1）preHandler：决定程序是否执行，返回Boolean2）postHandler：决定执行Handler之后，返回ModelAndView之前执行，统一返回视图3）afterCompletion:在Controller执行完之后执行，进行统一的异常或日志操作在spring的类加载配置文件中配置拦截器实现类，即处理器映射器中配置ref bean=“id”， 针对全局配置可以在spring类加载文件中红配置： &lt;mvc:interceptors&gt; &lt;!-- 多个拦截器，顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;!-- /**表示所有url包括子url路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;cn.com.mvc.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 继承或实现WebRequestInterception接口1）preHandler：返回值为void2）postHandler：执行Handler之后，返回ModelAndView之前执行,返回ModelMap,来改变Model3）afterCompletion：将WebRequest参数中不需要的准备资源释放掉主要进行请求前及请求后拦截，该接口参数没有response，只有request ，参数含有WebRequest ，含有三个属性（SCOPE_REQUEST,SCOPE_SESSION,SCOPE_GLOBAL_SESSION） 拦截器链：拦截器按照spring中顺序，顺序执行 拦截器可以作为登录拦截，判断session中user对象是否为空，判断为是否登录过 第八部分SpringMVC与前段页面常见的交互类型（一）上传文件 servlet，使用multipart/form-data 属性传输，包装成HttpServletRequest对象，再由servlet处理 在springmvc.xml中配置multipart类型加载器 ，使用MultiPartFile类来接受request请求中的multipart文件数据；若为文件类型，使用UUID.randomUUID方法生成随机名称；将存储路径及图片文件合并，生成file对象，在执行transferTO方法，将内存中图片缓冲写入设置的路径中，大文件可用IO流进行读写，并且实时返回读写进度；回显图片时候，将图片名称放入Model对象即可 如果把文件存储在服务器中，需要修改tomcat配置中的虚拟路径，对应对相应的绝对路径 当传入多张图片时候，使用MultipartFile数组 （二）JSON交互JSON格式(int,boolean,null不需要加””)普通：{“key”:”value”}数组：{“key”:[{“key1”:”value”} ,{“key2”:”value”} ,{“key3”:”value”} ]} 使用方括号对象：{“key”:{“key1”:”value”,”key2”:”value”,”key3”:”value”}}使用中括号 利用类型转换器（messageConverters），在相应的Controller方法中，输入参数或者返回参数之前添加@RequestBody注解，根据contentType类型，如果为application/json 就将其转换为JSON@ResponseBody该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 当返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； （三）RESTful风格RESTful:表现层状态转换；规范资源获取URL路径；RESTful约束：URL中不会出现动词，使用HTTP的动词（GET,POST,PUT,DELETE）;充分利用HTTP方法：GET：获取资源,POST：新建资源,PUT：更新资源,DELETE：删除资源 使用RequestMapping（value=”/url/{id}”，method={RequestMethod.GET}）,在请求路径中获得动态数据{id}，使用@PathVariable（”id”）注解，将id赋值给其他参数 web框架不支持除了post跟get方法时候，在请求数据中添加 “_method”参数，然后再web.xml中配置hiddenHttpMethodFilter的过滤器 web.xml规定了，url后缀为”.action”就交付给springmvc前端控制器，改为 / 所有路径请求都可以被springmvc处理，但是静态页面的访问也会带来错误，第一种解决方法：在springmvc.xml中使用&lt;mvc:resources location=”/js” mapping=”路径”/&gt;将需要加载的静态资源的URL路径配置在路径标签中；在springmvc.xml中mvc:default-servlet-handler/ 使用默认的servlet处理器，对进入DispatchServlet前端控制器的请求进行筛选，没有经过映射的请求交由web应用默认的servlet处理","categories":[],"tags":[]},{"title":"算法程序记录","slug":"基础算法程序记录","date":"2019-07-08T14:39:32.000Z","updated":"2019-08-05T14:53:37.480Z","comments":true,"path":"2019/07/08/基础算法程序记录/","link":"","permalink":"https://zhj1988.github.io/2019/07/08/基础算法程序记录/","excerpt":"简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中）","text":"简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中） 第一题二分法，对有序序列进行查找 public static int search(int[] arr, int key) { int start = 0; int end = arr.length - 1; while (start &lt;= end) { int middle = (start + end) / 2; if (key &lt; arr[middle]) { end = middle - 1; } else if (key &gt; arr[middle]) { start = middle + 1; } else { return middle; } } return -1; } 第二题给定数组，和一个target值，求返回数组中两个元素之和与target相等的下标 我的做法，首先考虑考虑两个方面，第一个是返回的是所有和与target相等的元素下标，并且不重复；如{1,3,2,2,2}，返回{0,1,2,3}java程序： public static int[] twoSum(int[] nums, int target) { int x=0; int y=0; int x1[]=new int[nums.length/2]; int y1[]=new int[nums.length/2]; for(int i=0;i&lt;nums.length;i++){ if(i==0 || find(y1,i)){ int temp=target-nums[i]; for(int j=i+1;j&lt;nums.length;j++){ if(nums[j]==temp &amp;&amp; find(y1,j)){ x1[x]=i; x++; y1[y]=j; y++; break;} } } } System.out.println(x+&quot; &quot;+y); if(y1[0]==0 &amp;&amp; x1[0]==0){ return null; }else{ int[] result =new int[x+y]; for(int i=0;i&lt;result.length;i=i+2){ result[i]=x1[i]; result[i+1]=y1[i]; } return result;} } public static boolean find(int[] num,int y){ for(int i=0;i&lt;num.length;i++){ if(y==num[i]){ return false; } } return true; }总结：考虑相对周全，但是代码繁琐，不够简洁，只适用了数组的数据结构，用int 值代替指针作用，做到链表结构逻辑 网上方案：由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止如果最终都没有结果则抛出异常时间复杂度：O(n) class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt; nums.length; i++) { if(map.containsKey(target - nums[i])) { return new int[] {map.get(target-nums[i]),i}; } map.put(nums[i], i); } throw new IllegalArgumentException(&quot;No two sum solution&quot;); } }总结：使用map数据结构，map.containsKey(target - nums[i]))，整体思路简洁，采用对比的方法，没有符合的结果即继续添加，由于哈希mao的时间复杂度，尽量多使用map结构疑问：target为3，当添加两个2，之后添加1，返回的是第一个2下标还是第二个2下标，解决问题的关键，在于阅读map.containKey源代码 针对疑问的解析： 第三题给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 我的做法，使用ListNode存储结构，当判断结点都不为空时，停止循环；注意点：保存头结点，否则无法返回；java程序（时间11ms）： class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int sum=0; ListNode listNodeTemp = new ListNode(0); ListNode l3= listNodeTemp ; int z1=0; int z2=0; while(l1!=null || l2!=null){ int temp1=0; int temp2=0; if(l1!=null){ temp1=l1.val; l1=l1.next; } if(l2!=null){ temp2=l2.val; l2=l2.next; } int x =temp1+temp2+z1; z2=x%10; z1=x/10; listNodeTemp.next =new ListNode (z2); listNodeTemp = listNodeTemp.next; } if(z1&gt;0){ listNodeTemp.next =new ListNode (z1); } return l3.next; } }网上解法： class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while(p != null || q != null){ int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = x + y + carry; carry = sum/10; curr.next = new ListNode(sum % 10); curr = curr.next; if(p != null) p = p.next; if(q != null) q = q.next; } if(carry &gt; 0){ curr.next = new ListNode(carry); } return dummyHead.next; } }总结：网上的java速度最优解法（10ms）与我大同小异，逻辑方面基本一致，差别点在于对结点的非空判断，我一次性将ListNode.val的赋值，与ListNode.next指向下一个结点完成，网上则分开判断 第四题给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 我的解法：由于第二题的教训，使用查找的时候，尽量使用Map结构，所以本次使用了Map结构，首先思考查找重复字符，使用了 map.containsKey(num[i])返回boolean来判断，同时相对应调整，现存的最大长度，设置max初始值为0，避免输入s =””;考虑了发生重复时候，返回的为重复字符的下一个下标，并且，如果重复的字符下标小于start，则不重复值，ex：abba，正确返回值为2,abb时候，start为2，abba时候，重复字符下标&lt;start,如果此时赋值，则错误；最后考虑到退出循环时候，如果一直不出现重复的字符，则max为0，所以将max与temp判断 java程序（28ms）： class Solution { public static int lengthOfLongestSubstring(String s) { char[] num= s.toCharArray(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; int temp = 0; int start= 0; int end= 0; for(int i=0;i&lt;num.length;i++){ if(map.containsKey(num[i])){ if(max &lt; temp){ max=temp; } if(map.get(num[i])&gt;=start){ start = map.get(num[i])+1; } } end = i; map.put(num[i],i); temp=end-start+1; } if(max&lt;temp){ max=temp; } return max; } }网上解法（用时10ms） public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) { i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; } return ans; } }总结：网上解法相对简洁，变量使用少，使用s.charAt(j)获得字符，而我则是使用字符数组存储浪费内存；使用Math.max（）比较大小，使得整体简洁；最牛逼的地方在于使用int[] index=new int[128] 表示一个字节大小数组，将对应字符值比作数组下标，当有值进入时，赋予该下标对应的String s 字符所在下标+1，同理为end值；使用i来当作start值；之后在深入分析，今天就到这里吧，此解法值得看一看 五、给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。假设 nums1 和 nums2 不会同时为空。 我的解法：定义两个int middle1，middle2类型的数字来收纳可能为数组中值，若是两个数组长度和为偶数，则最终取值为（middle1+middle2）/2.0,如果除以2，则结果依旧为整型；创建一个for循环，循环次数为最后得中值的下标，nums1长度为2，nums2长度为3，那么循环次数为3；进入循环中，进入for循环有一个前提，即是肯定有元素可以存入middle1中，理解这点可以减少很短不必要的判断；进入第一层判断，数组是否为空，分为两个数组都不为空，任一为空；第二层判断，不为空的情况，判断是否有任一数组的已经陪取空；退出for循环，判断两数组和是否为偶数进行相应操作 java程序（12ms）： class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int middle1 =0; int middle2 = 0; int length =(nums1.length+nums2.length)/2+1; double result = 0; int point1 = 0; int point2 = 0; for(int i=0;i&lt;length;i++){ middle2 =middle1; if(nums1.length!=0 &amp;&amp; nums2.length != 0){ if(point1&lt;nums1.length&amp;&amp;point2&lt;nums2.length) { if(nums1[point1]&lt;nums2[point2]){ middle1=nums1[point1]; point1++; }else{ middle1=nums2[point2]; point2++; } }else if(point1 == nums1.length){ middle1=nums2[point2]; point2++; }else { middle1=nums1[point1]; point1++; }} else if(nums1.length==0) { middle1=nums2[point2]; point2++; } else{ middle1=nums1[point1]; point1++; } } if((nums1.length+nums2.length)%2==0){ result = (middle1+middle2)/2.0; }else{ result = middle1; } return result; } }网上程序（2ms的大神）： class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; if (m &gt; n) { int[] tmp = nums2; nums2 = nums1; nums1 = tmp; m = nums1.length; n = nums2.length; } if (m == 0) return (nums2[n / 2] + nums2[(n - 1) / 2]) / 2.0; int imax = m; int imin = 0; int i = 0, j = n / 2; while(imin &lt; imax) { i = (imax + imin) / 2; j = (m + n) / 2 - i; if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) { imax = i; } else if (j &gt; 0 &amp;&amp; nums2[j - 1] &gt; nums1[i]) { imin = i + 1; } else break; } if (imin == imax) { i = (imax + imin) / 2; j = (m + n) / 2 - i; } // System.out.println(i + &quot; &quot; + j); if ((m + n) % 2 == 1) { if (i == m) return nums2[j]; else return Integer.min(nums1[i], nums2[j]); } if (i == 0) { if (j == n) return (nums1[i] + nums2[j - 1]) / 2.0; return (Integer.min(nums1[i], nums2[j]) + nums2[j - 1]) / 2.0; } else if (i == m) { if (j == 0) return (nums1[i - 1] + nums2[j]) / 2.0; return (Integer.max(nums1[i - 1], nums2[j - 1]) + nums2[j]) / 2.0; } else { return (Integer.max(nums1[i - 1], nums2[j - 1]) + Integer.min(nums1[i], nums2[j])) / 2.0; } } }总结： 第五题在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 网上程序： class Solution { Map&lt;Integer, Integer&gt; depth; Map&lt;Integer, TreeNode&gt; parent; public boolean isCousins(TreeNode root, int x, int y) { depth = new HashMap(); parent = new HashMap(); dfs(root, null); return (depth.get(x) == depth.get(y) &amp;&amp; parent.get(x) != parent.get(y)); } public void dfs(TreeNode node, TreeNode par) { if (node != null) { depth.put(node.val, par != null ? 1 + depth.get(par.val) : 0); parent.put(node.val, par); dfs(node.left, node); dfs(node.right, node); } } }链接：https://leetcode-cn.com/problems/two-sum/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-leetcode/ 总结：这一点思想相对简洁，主要难点在于创建两个map分别保存其深度和父类结点 ；其二在于递归函数中， 使用 par != null ? 1 + depth.get(par.val) : 0 判断保存并其深度1+父结点深度； 第六题给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 网上程序： public String longestPalindrome(String s) { if (s == null || s.length() &lt; 1) return “”; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1); } private int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) { L--; R++; } return R - L - 1; }链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/ 第七题给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转，如果反转后整数溢出那么就返回 0。 网上程序（6ms）： class Solution { public int reverse(int x) { int res = 0; int of = ((1 &lt;&lt; 31) - 1) / 10;//二进制左移31位，/10为了符合while循环中的条件 while (x != 0) { if (Math.abs(res) &gt; ((1 &lt;&lt; 31) - 1) / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }链接：https://leetcode-cn.com/problems/two-sum/solution/reverse-integer-by-jin407891080/ 总结：难点在与溢出处理，使用左移31位，找到最大值 第八题请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 链接：https://leetcode-cn.com/problems/string-to-integer-atoi java程序（8ms）： class Solution { public int myAtoi(String str) { long sum= 0; int result = 0; int sign = 1; Boolean flag = true; int max = Integer.MAX_VALUE; for(int i=0;i&lt;str.length();i++){ char s = str.charAt(i); if(s != &apos; &apos; ){ if(flag){ if((s&gt;=&apos;0&apos; &amp;&amp; s&lt;=&apos;9&apos;) || s==&apos;-&apos; || s==&apos;+&apos;){ flag = false; if(s == &apos;-&apos;){ sign = -1; }else if(s == &apos;+&apos;){ } else{ sum = s-&apos;0&apos;; result = (int)sum; } }else{ return 0; } }else{ if(s&lt;&apos;0&apos;||s&gt;&apos;9&apos;){ return result*sign; }else{ sum = sum*10; sum = sum+(s-&apos;0&apos;); result = (int)sum; if(sum &gt; max){ if(sign==1){ return max; }else{ return max*sign-1; } } } } }else{ if(!flag){ return result*sign; } } } return result*sign; } }总结：做法与网上解法相差不大，以Boolean判断是否 int开头，在判断是否溢出时，应处理更简洁，应整合一部分判断语句； 第九题字符串匹配没有解出来 第十题给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 链接：https://leetcode-cn.com/problems/container-with-most-water Java程序： public int maxArea(int[] height) { int size=0; for(int i = 1;i&lt;height.length;i++){ int temp =0 ; for(int j = 0; j&lt;i;j++){ temp = Math.max(Math.min(height[j],height[i])*(i-j),temp); } size = Math.max(size,temp); } return size; }总结：这个题目相对比较简单一下就想到暴力列举方法，执行了一下，效果不尽人意，之后参考了解题思路写出了下面的算法 public int maxArea(int[] height) { int start=0; int end=height.length-1; int max=0; while(start+1 &lt;= end){ max = Math.max(max,(end-start)*Math.min(height[start],height[end]) ); if(height[start]&lt;height[end]){ start++;} else {end--;} } return max; }总结：采用双指针的方法，这个题目制约着容器的最大容量，一个是两端的距离长度，一个两端中最小的那个端值；通过双指针法，从两端出发，首先使长度最大，然后使用排除法，端直小的那一段向中间移动（因为端值大的移动后，容量最大值并不会出现在此种情况中），循环至两端相邻结束 第十一题罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 链接：https://leetcode-cn.com/problems/integer-to-roman java程序： class Solution { public String intToRoman(int num) { String result = &quot;&quot;; int n = 0; while(num&gt;0){ int temp = num%10; num = num/10; result = find (temp,n) + result; n=n+2; } return result; } public static String find (int temp,int n ){ String result = &quot;&quot;; String[] sign = {&quot;I&quot;,&quot;V&quot;,&quot;X&quot;,&quot;L&quot;,&quot;C&quot;,&quot;D&quot;,&quot;M&quot;}; switch(temp){ case 0: result =&quot;&quot;; break; case 1: result = sign[n]; break; case 2: result = sign[n]+sign[n]; break; case 3: result = sign[n]+sign[n]+sign[n]; break; case 4: result = sign[n] + sign[n+1]; break; case 5: result = sign[n+1]; break; case 6: result = sign[n+1]+ sign[n]; break; case 7: result = sign[n+1]+ sign[n]+sign[n]; break; case 8: result = sign[n+1]+ sign[n]+sign[n]+sign[n]; break; case 9: result = sign[n] + sign[n+2]; break; } return result; } }总结：没什么好说的，简单的逻辑循环判断","categories":[],"tags":[]},{"title":"MyBatis配置文件总结","slug":"MyBatis配置文件详细解析","date":"2019-07-08T03:47:38.000Z","updated":"2019-07-12T05:05:38.931Z","comments":true,"path":"2019/07/08/MyBatis配置文件详细解析/","link":"","permalink":"https://zhj1988.github.io/2019/07/08/MyBatis配置文件详细解析/","excerpt":"简介：本篇博客记录学习MyBatis配置文件中一些知识点跟总结，以提供给大家复习或者查看某个为学习到知识点，不适合初学者看，其中有什么错误的地方，欢迎指正。","text":"简介：本篇博客记录学习MyBatis配置文件中一些知识点跟总结，以提供给大家复习或者查看某个为学习到知识点，不适合初学者看，其中有什么错误的地方，欢迎指正。 MyBatis配置文件分为四个部分学习 数据库配置文件SqlMapConfig SQL映射配置中输入映射的配置 SQL映射配置中输出映射的配置 Mapper自动映射 第一部分数据库配置文件SqlMapConfig configuration 配置文件的顶级标签 properties 属性提供整个配置文件中其他的配置使用properties标签可以引入一个可动态变换的外部配置，如db.properties &lt;properties resource = &quot;dataSource.properties&quot;&gt; &lt;property name = &quot;username&quot; value = &quot;root&quot;/&gt; &lt;property name = &quot;password&quot; value = &quot;123456&quot;/&gt; &lt;/properties&gt;其中dataSource.properties为项目一个配置文件，可以在其中修改，driver，url，name，password，相应的数据库连接池的信息会影响，在程序中，property属性，代表SqlMapConfig配置文件中可以修改dataSource.properties的属性值，name对应变量名，其他配置地区，使用value = “${username}”,即可调用出username对应的值，若在引用中使用value = “${username：root}”，即设置username默认值为root，要设置当username为空或者不存在时默认值。*. properties避免了数据库配置信息硬编码 setting配置分析setting 影响Mybatis框架在运行时候的一些行为，如配置缓冲，延迟加载等待，下面详细介绍一下；1）cacheEnable ：是否使用缓存，全局缓存的开关，默认值true（开启二级缓冲，Mapper，一级缓冲在SqlSession对象中，也要在mapper.xml文件中添加） 2）lazyLoadingEnglish ：是否开启延迟加载 ，默认值false3）aggressiveLazyLoading：是否需加载属，开启后调用方法加载对象，都会加载对象所有属性，关闭之后只会按需加载，默认值 false4）multipleResultSetsEnable：是否允许单一语句返回多结果集，即Mapper 配置中单一的SQL配置是否返回多个结果集， 默认值true5）useColumnLabel：使用列标签代替列名，默认值true6）useGenerateKeys:是否支持JDBC自动生成主键 ，默认值false7）autoMappingBehavior： 指定Mybatis自动映射的字段或属的方式，NONE,PARTIAL,FULL，默认值 PARTIAL（只会自动映射没有定义结果集的结果映射）8）autoMappingUnknownColumnBehavior：设置当前自动映射时发现未知列的动作，NONE,WARNING,FAILING,默认值为NONE9)defaultExecutorType:设置默认的执行器SIMPLE,REUSE,BATCH,默认值为SIMPLE(普通执行器会重用与处理语句)a）defaultStatementTimeout：设置超时时间b）defaultFetchSize：设置驱动的结果集获取数量的提示值（fetchSize），防止获得的结果过多，导致内存溢出c）safeRowBoundEnable：允许嵌套语句中使用分页（行内嵌套语句），默认值false（允许）d）mapUnderscoreToCamelCase：是否开启驼峰命名规则映射，默认falsee）localCacheScope：利用本地缓存机制，防止循环引用和加速重复嵌套查询，即sqlsession对象是否共享，默认值SESSION(缓存一个会话中执行的所有查询，数据共享)，STATEMENT（对相同的session不同调用，不会共享数据）f）jdbcTypeForNull：JDBC类型的默认设置，当没有参数提供特定的JDBC类型时，某些驱动需要指定列的JDBC类型（NULL,VARCHAR,OTHER）,默认值为OTHER10）lazyLoadTriggerMethods：指定哪个对象的方法触发一次延迟加载，ex：value =”equals,clone,hashCode,toString”ex: &lt;settings&gt;&lt;setting name =&quot;cacheEnable&quot; values = &quot;true&quot; /&gt; &lt;/settings&gt; typeAliases为sql映射文件中输入/输出参数设置类型别名，然后在sql映射配置文件中指定输入/输出参数类型时使用别名&lt;typeAliases&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;mybatis.po.User&quot;/&gt; &lt;typeAlias alias=&quot;str&quot; type=&quot;java.lang.String&quot;/&gt;&lt;/typeAliases&gt;批量定义别名，定义一个包装类的类，别名规范就是对应类的类名首字母变为小写&lt;typeAliases&gt; &lt;package name=&quot;mybatis.po.User&quot;/&gt;&lt;/typeAliases&gt;别名也可以在需要指定别名的类声明头添加注解”@Alias”@Alies(&quot;user&quot;) public clase User{//代码 }Mybatis对java常见类型默认指定了别名，可以直接使用_long /long, _int/int , string/java.lang.String ,int/java.lang.Integer , list/java.util.List typeHandlers 类型处理器声明自己的类型处理器（将从数据库获取的值以合适的方式转换成java类型，将java类型的参数转换成数据库对应的类型）三个步骤：1）编写类型处理器类一般要实现org.apache.ibatis.type.TypeHandler类型接口，接口泛式指定要转化的java参数类型主要改写四个方法：public void setParameter（PreparedStatement ps，int i，String parameter，JdbcType jdbcType）在sql配置传入参数时（新增，修改，删除，条件查询）做处理public String getResult（Resulset rs，String columnName）根据字段名public String getResult（Resulset rs，int colcolumnIndex）根据字段下标public String getResult（CallableStatement cs，int colcolumnIndex）供存储过程使用2）在MyBatis全局配置文件中配置该类型处理器在SqlMapConfig中使用标签来注册类型处理器 &lt;typeHandlers&gt;&lt;typeHandler handler=&quot;mybatis.test.DataTypeHander&quot; javaType=&quot;java.util.Data&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt; &lt;typeHandlers/&gt;3）在SQL映射配置文件中使用xxxMapper.xml中的语句中添加自定义的类型处理器的处理配置，ex：insert into user（username，password，regdate）Values（#{usename}，#{password}，#{regdate，javaType=date，jdbcType=TIMESTAMP，typeHandler=mybatis.test.DateTypeHandler}）设置参数regdate，会将java的Date类型转换成数据库需要的timestamp类型补充不适用TypeHandler接口，可以继承org.apache.ibatis.type.BaseTypeHandler方法（setNonNUllParameter，getNullParameter（三个）总四个方法，同TypeHandler接口四个方法） objectFactory对象工厂，创造实体对象的类，即实例化查询结果所对应的目标类（目标类的默认构造方法；目标类的有参构造方法）若自己创建对象工厂，继承DefaultObjectFactory类，改写相关四个方法，在全局配置文件SqlMapConfig中添加配置，使对象工厂生效；当Resource资源类加载SqlMapConfig.xml文件，创建SqlSessionFactory时候，会加载配置文件中的自定义ojectFactory plugins（插件）执行程序过程对某一点进行拦截，并在拦截之后做出一系列处理，即拦截器，对某种方法进行拦截调用的机制，被称为plugin实现一个plugin类，继承Interceptor接口，并且指定需要拦截的方法的签名信息“@Intercepts”拦截器注解，该注解声明此类是一个插件类；”@Signature”签名信息注解，每个注解中的参数分别为拦截的方法所属接口类型（type），拦截方法名称（method）以及所需要的参数信息（args），其中intercept方法是一个对目标方法进行拦截的抽象方法，而pligin方法的作用是将拦截器插入目标对象，setProperties方法的作用是将全局配置文件中的参数注入插件类，最后在全局配置文件SqlMapConfig中配置该插件。plugin使用场景：日志记录，权限控制，缓存控制等 environments放置有关数据库连接数据的配置标签，可以配置多个数据库连接环境，一个environment包含两部分，事务管理器（transactionManager），数据源（DataSource）信息1）事务管理器类型：a）JDBC，相当于直接使用jdbc的提交和回滚设置 &lt;transactionManager type=&quot;JDBC&quot; /&gt;&lt;property name =&quot;... &quot;, value = &quot;...&quot;/&gt; &lt;/transactionManager&gt;b）MANAGED，不提交和回滚连接，而是由容器来管理事务的生命周期，默认关闭连接，动态指定closeConnection参数，当设置为”false”，在MANAGED类型下不会自动关闭连接&lt;transactionManager type=&quot;MANAGED&quot; /&gt;&lt;property name =&quot;closeConnection &quot;, value = &quot;false&quot;/&gt; &lt;/transactionManager&gt;2)数据源（DataSource）三种内建数据源类型：a）UNPOOLED设置每次请求时打开和关闭连接b）POOLED设置一个管理数据库连接的资源池，用来合理控制数据库连接与关闭的次数 c）JNDI配置连接外部数据源（如服务器提供的数据源）支持配置多个数据库连接环境，配置”databaseIdProvider”参数，在SqlMapConfig中添加： mappers基于sql映射文件，即Mapper配置文件，SqlSession类，读取Mapper配置文件中的sql，通过全局配置文件自己中，mappers配置方式：1）使用相对路径进行配置：&lt;mappers&gt; `&lt;mapper resource=&quot;org/mybatis/mappers/UserMapper.xml&quot;/&gt;` `&lt;mapper resource=&quot;org/mybatis/mappers/CustomerMapper.xml&quot;/&gt;` &lt;/mappers&gt;2)使用绝对路径进行配置： &lt;mappers&gt; `&lt;mapper url=&quot;file：///var/mapper/UserMapper.xml&quot;/&gt;` `&lt;mapper url=&quot;file：///var/mapper/CustomerMapper.xml&quot;/&gt;` &lt;/mappers&gt;3）使用接口信息进行配置：&lt;mappers&gt; `&lt;mapper class=&quot;org.mybatis.mappers.UserMapper.xml&quot;/&gt;` `&lt;mapper class=&quot;org.mybatis.mappers.CustomerMapper.xml&quot;/&gt;` &lt;/mappers&gt;4)使用接口所在包进行配置：&lt;mappers&gt; `&lt;package name =&quot;org.mybatis.mappers&quot;/&gt;` &lt;/mappers&gt; Mapper映射文件Mapper文件即sql语句的配置文件，创建会话SqlSessionFactory映射文件总体介绍 ：insert ，update，select，delete，resultMap，cache，sql，cache-ref标签中各个属性含义：id：sql映射配置的唯一标识，可以代表sql配置，所属标签parameterType ：传入sql配置中需要的类型的类名或者别名resultType：配置sql语句执行后期望得到的结果数据类型resultMap：引入外部结果集配置，该结果集配置对应sql结果中的每个字段名称，即将映射到java对象中的哪些属性fetchSize：每次批量返回结果的行数resultSetType:设置结果集类型resultSets：当多个结果集时使用，为返回的每个结果集设定一个名称，以逗号分开 第二部分 Mapper配置输入映射输入配置参数属性配置在paramterType，基本数据类型，int，char，boolean基本数据包装类，Byte，Integer，java复杂数据类型，javabean 包装类型 Handler（类型处理器）当需要为传输参数指定一个特殊的数据库类型时，在#{}添加类型处理 #{age，javaType=int,jdbcType=NUMERIC,typeHandler=AgeTypeHandler} numericScale(添加小数点位数设置)保留两位小数点ex： #{price，javaType=double,jdbcType=DECIMAL,numericScale=2} 使用存储过程，设置一个参数“mode”，其值有IN（输入参数，可多个），OUT（输出参数，至多一个），INOUT（输入/输出参数，至多一个） &lt;select id=””statementType=”CALLABLE”parameterType=”hashmap”&gt; 向sql语句中插入一个不会被改变的字符串或者向拼接sql语句，使用${} 原javaBean，User类，使用UserInstant extends User，按照后续的要求修改UserInstant而不用修改原始的User，定义一个UserQuerInfo，含有UserInstant属性，则可以使用set，get方法一次性加载或存储UserInstant类型； 第三部分 Mapper配置输出映射 resultType 类型特点：1）不管输出javaBean单个对象还是一个列表，在Mapper映射文件中resultType类型是一样的输出单个对象，返回javaBean对象类型，输出一个列表，返回List； 2）如果没有合适的javaBean接受结果集数据，resultType输出HashMap类型的数据，将输出字段名称作为map的key，value作为字段值，为集合时，list resultMap类型返回结果为多个值，没有一个完全与返回结果值一一匹配的封装类接受，使用一个容器接受结果数据，到业务层再处理，resultMap 和数据库列名column 与javaBean属性名之间创建映射关系ex： &lt;resultMap id=&quot;productResult&quot; type=&quot;cn.com.mybatis.po.Product&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;product_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;product_name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryProductInfo&quot; parameterType=&quot;int&quot; resultMap=&quot;productResult&quot;&gt; select `P.id as pid,` `U.email as user_email` from product P where P.id = #{id} &lt;/select&gt;id property：主键； result property:非主键； 引入外部Mapper，使用namespace.id1)association标签:关联嵌套结果，表明返回的结果集对象中，java包装类中还含有其他java包装类，应用于表与表关联，一对一的关系中ex： &lt;resultMap id=&quot;GamePlayerResult&quot; type=&quot;cn.com.mybatis.po.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;name&quot;/&gt; &lt;association property=&quot;professionalAttributes&quot; javaType=&quot;java.util.HashMap&quot;&gt;`&lt;id property=&quot;pid&quot; column=&quot;product_id&quot;/&gt;` `&lt;result property=&quot;pname&quot; column=&quot;product_name&quot;/&gt;` &lt;/association&gt; &lt;/resultMap&gt;如果已经定义好包装类嵌套的包装类，则可以这样定义&lt;association property=&quot;user&quot; javaType=&quot;myBatis.po.User&quot; resultMap = &quot;userResult&quot;/&gt;2）connection标签：集合的嵌套结果，包装类中包含一些List集合属性，便于对Mybatis对包装类中的集合类型属性进行映射，应用于一对多的关系中ex： &lt;resultMap id=&quot;productResult&quot; type=&quot;cn.com.mybatis.po.Product&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;product_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;product_name&quot;/&gt; &lt;collection property=&quot;users&quot; ofType=&quot;cn.com.mybatis.po.User&quot;&gt; `&lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;` `&lt;result property=&quot;username&quot; column=&quot;user_username&quot;/&gt;` &lt;/collection&gt; &lt;/resultMap&gt;3）鉴别器：resultMap根据”professionType”字段的不同，映射不同的resultMap信息 `&lt;discriminator javaType=&quot;int&quot; column=&quot;profession_type&quot;&gt;` `&lt;case value=&quot;1&quot; resultMap=&quot;warriorResult&quot;/&gt;` `&lt;case value=&quot;2&quot; resultMap=&quot;magicianResult&quot;/&gt;` `&lt;/discriminator&gt;` 第四部分Mapper自动映射以及配置动态sql语句 第一部分 autoMappingBehavior（自动映射设置主要在SqlMapConfig中，setting标签中，name= value= ）：指定Mybatis自动映射的字段或属的方式，NONE,PARTIAL,FULL，默认值 PARTIAL（只会自动映射没有定义结果集的结果映射）；PARTIAL只对非嵌套的resultMap进行自动映射；FULL对所有resultMap都进行自动映射，可能会造成某些嵌套属性和结果的字段名一致而被映射；NONE不能进行自动映射 autoMapping（在resultMap中定义，忽略SqlMapConfig中的设置）：false不能自动映射，只能手动映射 包装类使用驼峰命名规则，在全局配置文件中设置mapUnderscoreToCamelCase，为true 第二部分 sql语句中可替换的条件或者sql语句ex：&lt;where&gt;&lt;if test=&quot;User!=null&quot;&gt;&lt;if test =&quot;User.id!=null and User.id!=&#39;&#39;&quot;&gt;and user.id = # {User.id}&lt;/if&gt;&lt;/if&gt;&lt;/where&gt;因为的存在自动忽略第一个and复用性较强的sql语句：&lt;sql id=&quot;use_id_check&quot;&gt;and user.id = #{value}&lt;/sql&gt;调用时： 向sql配置传递一个数组或者List类型的输入参数，使用ex:id=#{user_id} 使用foreach遍历传入的ids查询参数，在foreach标签中，collection指定输入对象中的集合属性，item指定每次遍历生成的对象名，open为开始遍历时要拼接的串，close为结束时候要拼接的串，separator为遍历对象中间需要拼接的串","categories":[],"tags":[]},{"title":"MyBatis入门介绍","slug":"MyBatis入门介绍","date":"2019-07-07T10:51:27.000Z","updated":"2019-07-14T07:54:21.120Z","comments":true,"path":"2019/07/07/MyBatis入门介绍/","link":"","permalink":"https://zhj1988.github.io/2019/07/07/MyBatis入门介绍/","excerpt":"简介：记录学习的MyBatis一些笔记 一个MyBatis web项目包含三个部分1. 源代码目录（src）2. 配置文件目录（config）3. 测试目录4. 扩展部分：高级映射","text":"简介：记录学习的MyBatis一些笔记 一个MyBatis web项目包含三个部分1. 源代码目录（src）2. 配置文件目录（config）3. 测试目录4. 扩展部分：高级映射 第一部分源代码目录1.数据库连接（datasource）创建DataConnection类，通过Resource资源加载类加载SqlMapConfig.xml配置文件，获得SQL会话工厂SqlSessionFactory，使用工厂创建可以与数据库交互的sqlSession类的实例对象。Resource -&gt; SqlSessionFactory -&gt; sqlSession类 2.持久层对象（po）持久化实体类是一个类中的成员变量与数据库表中字段一一相对应的java类，也有封装一些间接数据的实体类在老框架EJB中也有这种get/set方法，总而言之，将这种类称为JavaBean 3.测试主程序（test）通过DataConnection类获取sqlSession会话对象，然后是由sqlSession对象的SelectOne（返回多个使用SelectList），该方法有两个参数，第一个是sql映射文件UserMapper.xml中的namespace加上statement配置的id；第二个参数是sql映射文件中所匹配的parameterType类型参数，执行selectOne之后返回结果为sql映射文件中所匹配的resultType类型。 第二部分配置文件目录1.数据库连接配置文件SqlMapConfig.xml指定xml版本信息和编码格式信息DTD（document type definition）文档定义类型（信息规范约束）&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;文档定义类型（信息规范约束）settings标签：logImpl日志输出模式environment标签：MyBatis环境信息，代表一个单独的数据库配置环境（可多个environment）environment.transactionManager：MyBatis事务控制类型environment.datasource：数据库连接信息；其中多个property标签用于配置数据库驱动信息Driver，数据库连接地址url，数据库用户名username，数据库密码password 2.处理user数据的SQL映射文件sqlmap/UserMapper.xml指定xml版本信息和编码格式信息DTD（document type definition）文档定义类型（信息规范约束）&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;mapper标签：mapper.namespace属性:对SQL进行分类化管理实现不同业务的SQL隔离每个SQL标签：parameterType（输入参数类型）、parameterMap（输入参数集合，map结果）、resulType（结果类型）、resultClass（结果类，一般为java类）、resultMap （结果集合）ex： &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.com.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE id=#{id} &lt;/select&gt;在SqlMapConfig.xml中，configuration标签的最后必须配置 mappers &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/UserMapper.xml&quot;/&gt; &lt;mapper resource=&quot;sqlmap/CustomerMapper.xml&quot;/&gt; &lt;/mappers&gt; 3.日志输出环境的配置文件log4j.properties日志输出环境配置文件1）.log4j开源工具：将日志信息导出到控制台或文件2）.log4j配置参数文件（log4j.properties）a）log4j.rootLogger= DEBUG , stdout一共 七个级别：OFF, FATAL,ERROR( 错误级别，不影响程序运行的错误事件),WARN（异常级别，潜在的错误情形）,INFO（标准信息级别，用于日常运行在控制台打印程序运行的主要步骤）,DEBUG（调试级别，用于开发过程查看程序运行的详细步骤）,ALLstdout：将等级为DEBUG的日志信息输出到stdout参数所制定的输出载体中 b）log4j.appender.stdout = org.apache.log4j.ConsoleAppender设置stdout输出端载体类型：ConsoleAppender(控制台)，FileAppender（文件），DailyRollingFileAppender（每天产生一个新的文件），RollingFileAppender（文件大小达到指定大小时产生的一个新文件）WriterAppender(将日志信息以流的格式发送指定地方) c）log4j.appeder.stdout.layout =org.apache.log4j.PatternLayout名为stdout 的输出载体的layout（局面布局）那种类型。HTMLLayout/PatternLayout(指定布局)/SimpleLayout（包含日志信息级别和信息字符串）/TTCCLayout（包括日志产生的时间，线程、类别） d）log4j.appeder.stdout.layout.ConversionPattern = %5p[%t]-%m%nPatternLayout格式：%m输出代码指定信息，%p输出优先级，%r输出应用启动到log信息输出时间（ms），%c输出所属类目，%t输出生产该日志事件线程名，%n输出回车符号（windows：rn / UNIX：n），%d输出日志的日期或时间，%l输出日志事件发生位置，包括类目名，发生的线程，以及代码的行数。 第三部分测试目录测试部分综合前面源代码和配置文件，举例说明对数据库的各种操作 查询语句selectSQL映射文件sqlmap/UserMapper.xml 添加：&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE id=#{id} &lt;/select&gt;MybatisTest中调用mappper方法： `SqlSession sqlSession=dataConn.getSqlSession();` `User user=sqlSession.selectOne(&quot;test.findUserById&quot;,1);` （dataConn对象由 public DataConnection dataConn=new DataConnection() 创建） 模糊查询语句 selectSQL映射文件sqlmap/UserMapper.xml 添加：&lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.com.mybatis.po.User&quot;&gt; `SELECT * FROM USER WHERE username LIKE &apos;%${value}%&apos;` &lt;/select&gt;MybatisTest中调用mappper方法： `SqlSession sqlSession=dataConn.getSqlSession();` `List&lt;User&gt; userList=sqlSession.selectList(&quot;test.findUserByUsername&quot;,&quot;张&quot;);` 更新语句updateSQL映射文件sqlmap/UserMapper.xml 添加： &lt;insert id=&quot;insertUser&quot; parameterType=&quot;mybatis.po.User&quot;&gt; `&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;` `SELECT LAST_INSERT_ID()` `&lt;/selectKey&gt;` `insert into user(username,password,gender,birthday,email,province,city)` `value(#{username},#{password},#{gender},#{birthday,jdbcType=DATE},` `#{email},#{province},#{city})` &lt;/insert&gt;MybatisTest中调用mappper方法：SqlSession sqlSession=dataConn.getSqlSession();sqlSession.insert(&quot;test.insertUser&quot;,user);sqlSession.commit();sqlSession.close(); 删除语句deleteSQL映射文件sqlmap/UserMapper.xml 添加： &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt; `delete from user where id=#{id}` &lt;/delete&gt;MybatisTest中调用mappper方法：SqlSession sqlSession=dataConn.getSqlSession();sqlSession.delete(&quot;test.deleteUser&quot;,user);sqlSession.commit();sqlSession.close(); 修改语句updateSQL映射文件sqlmap/UserMapper.xml 添加： &lt;update id=&quot;updateUserName&quot; parameterType=&quot;mybatis.po.User&quot;&gt; `update user set username=#{username} where id=#{id}` &lt;/update&gt;MybatisTest中调用mappper方法：SqlSession sqlSession=dataConn.getSqlSession();sqlSession.update(&quot;test.updateUserName&quot;,user);sqlSession.commit();sqlSession.close(); 补充知识点：1）. 使用 ${}符号拼接sql语句串，如模糊查询中需要在两边拼接%，但是可能会引发sql注入风险，如果接收的简单类型，只能写value，如果接收的是javabean类型，通过OGNL读取对象中的属性值； #{}表示一个占位符，在#{id}其中id表示接收输入参数的名称，如果输入参数为简单类型（基本数据类型），那么#{}中可以是任意数据，如果接受的是JavaBean类型，通过OGNL读取对象中的属性值2）sqlsession，创建dataConn.getSqlSession()；方法:selectoOne，selectList，insert，update，delete（除了select，其他操作更新过后需要使用sqlSession.commit()，以提交更新操作）使用过后关闭sqlSession.close()3)对于 id主键自增设置的数据库表，执行insert不用插入id，如果想同时插入并获得主键，使用MYSQL函数，select LAST_insert_id()获取刚插入记录的自增主键，ex： &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt;或者在insert 标签中添加属性“useGenerateKeys”（使用自增主键）和“keyProperty”（java对象的属性），ex： &lt;insert id=&quot;insertUser&quot; parameterType=&quot;mybatis.po.User&quot; useCGenerateKeys = &quot;True&quot; keyProperty=&quot;id&quot;&gt;关于非自增主键的获取：执行sql方法uuid（）和Oracle的序列主键nextval（），ex：&lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT UUID() &lt;/selectKey&gt;或者 ex：&lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT 序列名.nextval() &lt;/selectKey&gt;4）MyBatis使用场景：以sql语句为核心的不完全的ORM（关系型映射）框架；Hibernate，只需要调用相关API即可，sql语句并不需要开发人员完成，缺点是不能对sql进行优化与修改 第四部分高级映射第一部分一对一与一对多查询 使用resultType实现 使用resultMap实现association标签，代表一对一，类中有其他类connection标签，代表一对多，类中有其他类的集合，List&lt;其他类&gt;根据实际情况两者互相嵌套ex： 第二部分延迟加载association标志，connection标签，具有延迟加载特性，具体表现为：查询语句时候，查询一个表，其关联表信息可以延迟加载相关设置：在全局配置文件中setting变量：使用lazyLoadingEnglish ：是否开启延迟加载 ，默认值false，设置为true，即按需加载；使用aggressiveLazyLoading：是否需加载属，开启后调用方法加载对象，都会加载对象所有属性，关闭之后只会按需加载，默认值 false ，设置为false，将积极加载改为消极加载 第三部分Mapper动态代理数据库取数据的逻辑会防止在DAO层中（Date，Access，Object，数据访问对象）使用MyBatis会节省DAO层开发时间实现Mapper代理的方法，创建接口interface接口，保持与某个mapper.xml配置文件相同，接口中方法定义的方法名，方法参数，方法返回类型都与mapper.xml类型相同，mapper的namespace指定interface接口的路径，即可使用SqlSession类获取Mapper代理&lt;mapper namespace=&quot;mybatis.mapper.CustomerMapper&quot;&gt;定义一个接口public interface CustomerMapper{ id….} 测试类中使用SqlSession类中的getMapper，加载的Mapper代理对象，由上的例子：CustomerMapper customerMapper = sqlSession.getMapper（CustomerMapper.class）获取到的Mapper对象，共享一个二级缓冲内存，当出现增删改操作时候，二级缓冲内存清空 总结一下配置环境与运行程序中遇到的错误： config文件夹没有添加到路径，所以 resource=”SqlMapConfig.xml”出错 mysql-connector-java-5.0.3-bin.jar版本太老（本人使用的是mysql8.0），在lib上添加 mysql-connector-java-8.0.15-.jar，再添加到路径之后完美解决问题。 本篇MyBatis入门知识就到这里了，后续关于配置文件的详解以及实战项目还在编写中。","categories":[],"tags":[]},{"title":"KMP算法程序实现与原理解析","slug":"KMP算法程序实现与原理解析","date":"2019-07-05T17:43:33.000Z","updated":"2019-07-09T17:09:28.580Z","comments":true,"path":"2019/07/06/KMP算法程序实现与原理解析/","link":"","permalink":"https://zhj1988.github.io/2019/07/06/KMP算法程序实现与原理解析/","excerpt":"简介：KMP算法于串结构中，查询字符串匹配，应用于字符查询等应用场景，本文介绍其原理，由最简答的朴素模式匹配算法（暴力算法）入手，到KMP算法及其优化算法介绍，如果有错误的地方，欢迎指正。","text":"简介：KMP算法于串结构中，查询字符串匹配，应用于字符查询等应用场景，本文介绍其原理，由最简答的朴素模式匹配算法（暴力算法）入手，到KMP算法及其优化算法介绍，如果有错误的地方，欢迎指正。 1. 朴素模式匹配算法原理：原字符数组s 长度n下标i，匹配字符组t 长度m下标j，从s[0]与t[0]开始比较，若相同，则i++，j++继续比较，若i = m，则完全匹配，此时t在s的下标为i-j+1；失配时候j =0 ；循环持续至i = n || j = m；t时间复杂度最坏情况 （n-m）*m ，最优情况 m改良朴素模式匹配算法：可以多次查询，如s = abcabc，t = abc，若没改良则只能输出i= 1 ；改良后i = 1,3；下面为程序实现改良的算法（java）：package demo;import java.util.Scanner;public class test { static String stringText = “abcabcabcabcabcabcabc”;//原数组 static char num1[]= stringText.toCharArray(); static String stringExample = null; public static void ViolentMatch() { int j=0; int i=0; int temp = 0; Scanner input=new Scanner(System.in); stringExample =input.next(); //输入匹配数组 char num2[]= stringExample .toCharArray(); long startTime = System.nanoTime(); //获取开始时间 while (i&lt;num1.length ) { if(num1[i] == num2[j]) { i++; j++; }else { i = i-j+1; j = 0; } if(j == num2.length) { System.out.println( i-j+1 );//输出匹配成功的原数组下标 j = 0; temp++; } } if(temp == 0) { System.out.println(-1);//没有匹配成功 } long endTime = System.nanoTime(); //获取结束时间 System.out.println(“程序运行时间：” + (endTime - startTime) + “ns”); //输出程序运行时间 } public static void main(String arg[]) { ViolentMatch(); System.out.println(“end”); }} 2.KMP算法终于进入正题了，KMP算法相比较朴素模式匹配算法，更加智能化，减少重复的工作，把之前比较的结果都会保留下来，然后呢，其最主要的重点就是next[j]数组的计算方式。原理：原字符数组s 长度n下标i，匹配字符组t 长度m下标j；首先计算next[j],开始匹配，匹配成功退出，匹配失败t相对于s，向右边移动j-next[j]-1距离。然后继续匹配直到j++ = m，或者i++ &gt; n next[j]函数定义next[j]函数三种情况：j=0时候，next[0]=-1；p1….pk-1 = pj-k+1….pj-1(1&lt;k&lt;j);0,其他情况。（书本或者其他网上资料，数组s[0],t[0]不存放数据，存放字符数组长度m/n，本篇程序s[0],t[0]存放数据）ex：模式串t:abcdef next[j]: -100000 ;模式串：abcabc next[j]:-100012；模式串：aaaaab next[j]:-101234匹配算法程序（java）： 求next[]程序： public static int[] get_next(String T) { char temp[]=T.toCharArray(); int next[] = new int[temp.length]; next[0] = -1; int k = -1; int j = 0; while (j &lt; temp.length - 1) { //p[k]表示前缀，p[j]表示后缀 if (k == -1 || temp[j] == temp[k]) { ++k; ++j; next[j] = k; } else { k = next[k]; //当匹配失败时候，返回next[]数组中k下标的值，如果一直失败将回溯k=-1 } } System.out.print(“next[]:”); for (int i = 0; i &lt; next.length; i++) { System.out.print(next[i]); if(!(i == next.length-1)) { System.out.print(“,”); }else { System.out.println(); } } return next; } ` KMP方法程序： public static void KMP() { int j=0; int i=0; int temp = 1; Scanner input=new Scanner(System.in); stringExample =input.next(); //输入匹配数组 char num2[]= stringExample .toCharArray(); int next[] = get_next(stringExample); long startTime = System.nanoTime(); //获取开始时间 while (i&lt;num1.length ) { if(num1[i] == num2[j]) { i++; j++; }else { i = i-j+1; j = j-next[j]-1;//T字符串匹配失败后下标 } if(j == num2.length) { System.out.print( &quot;第&quot;+ temp +&quot;个成功:&quot;); System.out.println( i-j+1 );//输出匹配成功的原数组下标 j = 0; temp++; } } if(temp == 1) { System.out.println(-1);//没有匹配成功 } long endTime = System.nanoTime(); //获取结束时间 System.out.println(&quot;程序运行时间：&quot; + (endTime - startTime) + &quot;ns&quot;); //输出程序运行时间 }总结：当重复段越多时候，KMP算法比较朴素算法更快 KMP算法的改进我觉得下面这篇博客内容解释比较容易理解，当失配的时候，j-&gt; next[j]，此时优化算法，避免多余步骤，当前缀与后缀相等时候，采用递归的方法，求出最优的next[j]数组只要出现了T[next[j]] = T[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用T[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == T[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。求优化后的数组的方法,求出优化数组： public static int[] get_nextval(String T,int[] next) { char temp[]=T.toCharArray(); int k = -1; int j = 0; while (j &lt; temp.length - 1) { if (k == -1 || temp[j] == temp[k]) { ++k; ++j; if (temp[j] != temp[k]) { next[j] = k; } //之前只有这一行 else { //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k];} } else { k = next[k]; //当匹配失败时候，返回next[]数组中k下标的值，如果一直失败将回溯k=-1 } } System.out.print(&quot;nextval[]:&quot;); for (int i = 0; i &lt; next.length; i++) { System.out.print(next[i]); if(!(i == next.length-1)) { System.out.print(&quot;,&quot;); }else { System.out.println(); } } return next; } 总结：对于KMP算法原理能够理解，但是程序实现程序部分不能够参透，只能用代入法判断真伪，继续加油琢磨吧！！！！！ 参考博客：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html","categories":[],"tags":[]},{"title":"数据结构与算法个人总结","slug":"数据结构与算法个人总结","date":"2019-07-01T15:37:13.000Z","updated":"2019-07-11T17:49:46.266Z","comments":true,"path":"2019/07/01/数据结构与算法个人总结/","link":"","permalink":"https://zhj1988.github.io/2019/07/01/数据结构与算法个人总结/","excerpt":"简介：本篇博客用于个人学习的总结，基于大话数据结构这本书，做一些个人的笔记以及查缺补漏，可能会有些乱，如果有什么错误 ，欢迎指正。 （完善中）","text":"简介：本篇博客用于个人学习的总结，基于大话数据结构这本书，做一些个人的笔记以及查缺补漏，可能会有些乱，如果有什么错误 ，欢迎指正。 （完善中） 线性表1. 顺序存储结构（在内存中是一段连续的存储空间）优点：方便查找，时间复杂度O（1）缺点：不方便删除，插入。平均时间复杂度O（N）删除或插入时候，第一判断插入位置是否正确，第二将插入位置后面的元素整体往后移动，若为删除则往前移动。主要通过数组来实现顺序存储结构。 2. 链式存储结构（在内存中存储位置随意，每个存储数据的地方为一个节点，其包括数据与指针）（1）单链表特点：插入或者删除大量数据时候非常方便，首先花费平均时间复杂度O(n)查找到插入位置，其次修改插入数据的指针，指向插入位置后一个元素，修改插入位置的前一个元素的指针，指向插入的数据节点。删除也类似操作。（2）静态链表特点：古老的语言，无指针时代，形式为数组。其由坐标，游标，数据三部分组成。第一，头结点游标指向第一个空闲位置的坐标。第二， 数组最大长度-1，的坐标结点其游标指向第一个结点的坐标。第三， 数组中，存放数据的最后一个结点，其游标值为0。（3）循环链表特点：最后一个结点的指针指向头结点，若是两个两个循环链表拼接成一个时候，需要删除一个头结点（补充内容，链表结构，有一个头结点，其数据可能为空，也可能为链表存放数据个数或者长度，其指针指向第一个结点位置）（4）双向链表（prior，next）特点：每一个结点有一个前驱指针，一个后驱指针，在遍历链表时候比较方便。ex：插入数据时候，需要按顺序进行四种操作，插入元素a，插入位置为p，p—&gt;next,之间。第一步，修改a前驱指针为p，第二步修改a后驱指针为p-&gt;next,第三步，修改p—&gt;next的前驱指针为a，第四步，修改p—&gt;next为a。以上四步，个人认为前三步位置可以任意变动，第四步位置不变即可。 以上为最基础的线性表 堆栈特点：先进后出，在表尾进行插入和删除操作，栈顶指针指向表尾，push进栈，pop出栈。 1. 顺序栈知识点：栈顶指针top，空栈时候，top为-1，进栈栈顶指针top++顺序栈中，两个栈共享空间，两个栈的栈底分别对应数据的第一个和最后一个，，第一个栈，栈底坐标为0,从0开始push，top1递增；第二个，栈底坐标为n。从n开始push，top2递减。空栈时候：top1 = 0，top2 = n，满栈时候：top1 + 1 = top2；这种共享空间可以看成，存数据时候，从两端往中间方向存储数据。 ##2. 链栈知识点：栈顶指针，放在单链表的头部，不需要头结点，基本没什么好说的了，举个出栈的例子吧；ex：第一步赋值*e = s-&gt;top-&gt;data；第二步，把栈顶结点赋值给p，p = s-&gt;top；第三步，s-&gt;top = s-&gt;top-&gt;next；第四步，释放空间p，free（p）。 ##3. 栈的应用第一个是递归应用第二个四则运算表达式，后缀表达式（不需要括号）下面详细说一下中缀表达式怎么转换成后缀表达式举个例子，中缀表达式： 5+5 *（2+5）-9/3，后缀表达式：5525+ * +93/-有两个栈，一个存放数字，一个存放运算符号，后缀表达式的运算：遇到符号，则将栈顶两个数字出栈中缀表达式转换成后缀表达式存放运算符号有两条准则：第一条，遇到左括号则把之后的运算符号都存起来直到遇到右括号；第二条，遇到运算符号优先级低于栈顶符号的优先级，则把栈顶以下优先级大于等于符号的全部出栈，如存入+，而栈顶为 * + ，则 * ，+ 出栈。 队列特点：先进先出，只允许在一端进行插入操作（队尾），而在另一端进行删除操作（队头）。 1. 顺序队列知识点：front指向队头，rear，指向队尾的下一个位置（两个指针使删除操作的时间复杂度为O(1)，删除操作，队列后面元素不用向前移动），但是顺序队列有假溢出现象，如满数组末尾元素被占用，则rea没得指向，由此引出循环队列。 2. 循环队列知识点：头尾相接的顺序结构称为循环队列；保留一个空间元素，存放rear。空栈时候：front ==rear；满栈时候：（rear + 1）/queuesize == front；队列长度：（rear - front + queuesize）/queuesize 3. 链式队列知识点：队头指针front 指向头结点，则栈顶元素为，Q-&gt;front -&gt;next ;队尾指针rear指向终端结点；空栈时候，Q-&gt;rear = Q-&gt;front. 4. 总结结构在确定队列长度最大值的情况下，适用循环队列，如果无法预估队列长度时使用链队列 串特点：字符组成的字符串，字符有8位ASCLL码，16位Unicode，indexof从左查找子串位置，lastindexof从右查找子串，trim，去除两边的空格。两串的连接concat，插入strinsert，字符的替换replace 1. 存储结构顺序存储结构：用一定的长度的数组存储，“\\0”表示串值的终结，计算串长度时候不加“\\0”链式存储结构：一个结点可以存放一个或者多个字符，用“#”将未被占满的结点补全；性能不如顺序存储结构。 2. 串涉及算法（两段字符串匹配问题）（1） 朴素模式匹配算法（2） KMP模式匹配算法关键点：next[j]计算问题 （3）KMP算法的改进 树定义：树的数据结构是一对多的关系，其中二叉树应用较多。n为树的结点个数，n&gt;0 时根结点唯一。结点拥有的子树数称为度，度为0的结点称为叶结点，度不为0的结点称为叶结点；结点的层次（根为第一层），结点的最大层次称为树的深度。 1. 树的存储结构1）双亲表示法：下标|数据|双亲结点|右兄弟结点（不在的结点值赋值为-1）2.0）孩子表示法：数据|度域（度数,表示分配的指针空间）|child（指针域）|child|….2.1）双亲孩子表示法链表：把每个结点的孩子排列起来，以单链表作为存储结构（从左到右，除了第一个元素后面都是同一层的兄弟），把n个头指针组成一个线性表，采用顺序存储结构，存放进一个一维数组。一维数组表结构：下标 data|parent（双亲下标，根结点为-1）|firstchild（指针，指向第一个孩子，最左边子结点）；链表结构：头结点-&gt;data|next -&gt;data|next-&gt;date|^3）孩子兄弟表示法：每个结点第一个孩子如果存在即唯一，右兄弟存在也唯一。 data|firstchild|rightchild 其优点为把复杂的树变成二叉树。 2. 二叉树的定义特点：结点的度n&lt;=2,有次序1）斜树：所有结点只有左二叉树叫左斜树，所有结点只有右二叉树叫右斜树。2）满二叉树：所有分支结点都存在左子树和右子树，所有叶结点都在同一层。相同深度的二叉树中，满二叉树的结点数最多，叶子数最多。3.0）完全二叉树：对一棵具有n个结点的二叉树按层编号，如果编号为i 的结点与同样深度的满二叉树中编码为 i的结点在二叉树中位置完全相同，则称为完全二叉树。3.1）完全二叉树特点：叶子结点只能出现在最下两层，最下层叶子集中在左边连续位置，倒数二层叶子集中右边连续位置。4）二叉树性质：1. 在第i层，至多右2^（i-1）个结点；2. 深度为k的二叉树至多有2^k -1 个结点；3. 分支结点（度为2）数量n1,终端结点n0， n0 = n1 +1；4. 具有n个结点的完全二叉树深度为【lgn / lg2 】+1;5. 对n个结点的完全二叉树编号，结点为i，则双亲结点为【i/2】，2i&gt;n,则i无左孩子，否则左孩子为2i，右孩子为2i+1 3. 二叉树存储结构1)二叉树的顺序存储结构：一般用于完全二叉树，按层编数组下标2)二叉链表：lchild|data|rchild 4. 遍历二叉树1）前序遍历：根结点，左子树，右子树2）中序遍历：左子树，根结点，右子树3）后序遍历：左子树，右子树，根结点4）层序遍历：从上到下，从左到右逐层遍历 程序： 5.线索二叉树1）原理：2）结构的实现（代码）：","categories":[],"tags":[]},{"title":"经典排序算法概述&&个人体会总结","slug":"程序经典排序算法个人体会与总结","date":"2019-06-30T10:58:10.000Z","updated":"2019-07-14T12:27:02.228Z","comments":true,"path":"2019/06/30/程序经典排序算法个人体会与总结/","link":"","permalink":"https://zhj1988.github.io/2019/06/30/程序经典排序算法个人体会与总结/","excerpt":"简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 （待完善）","text":"简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 （待完善） 首先是关于稳定性解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。—–来自百度百科（十分好理解） 1. 冒泡排序法（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 java程序： public class sort { static int[] ary = {2,1,3,45,12,56,88,44,1,2,6,7,89,3,45,44,72}; public static int[] BubbleSort(int[] ary) { for (int i = 0; i &lt; ary.length; i++) { boolean flag = true; for (int j = 0; j &lt; ary.length-i-1; j++) { int temp = 0; if(ary [j]&gt;ary [j+1]) { temp = ary [j+1]; ary [j+1]=ary [j]; ary[j]=temp; flag = false; } } if(flag) { System.out.println(&quot;数组长度:&quot;+ary.length ); System.out.println(&quot;第&quot;+(i+1)+&quot;层外循环，数组已经排序完成&quot;); break; } } return ary; } public static void main(String[] arg) { int[] result = BubbleSort( ary ); for (int i = 0; i &lt; result.length; i++) { System.out.print(result[i]); System.out.print(&quot; &quot;); } } }算法总结：稳定；时间复杂度：最优 O（n），最坏O（n^2），怎么最优解：第一层循环设定一个标志为true，在第二层循环，if判断是否交换数组元素时候，若交换则修改标志为false，第二层循环结束，若无交换，则标志任为false，此时写一个if判断，若为false，则break跳出循环，或者return退出方法。 2. 选择排序法(Selection-sort)选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 个人理解：选择排序法，每次固定两层循环，将未排序的剩余元素一一进行比较，排序得出该序列上位置的最优解，所以时间复杂度固定不变。 java程序： public static int[] SelectionSort(int[] ary) { int temp = 0; for (int i = 0; i &lt; ary.length; i++) { int num = i; for (int j = i; j &lt; ary.length-1; j++) { if(ary [num]&gt;ary [j+1]) { num = j+1; } } if(num!=i) { temp = ary [num]; ary [num]=ary [i]; ary[i]=temp; } } return ary; } 算法总结：时间复杂度，最优O（n^2）最坏O（n^2）； 不稳定，解释：举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 3. 插入排序（Insertion Sort）插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。从第一个元素开始，该元素可以认为已经被排序 算法步骤：1.取出下一个元素，在已经排序的元素序列中从后向前扫描；2.如果该元素（已排序）大于新元素，将该元素移到下一位置；3.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；4.将新元素插入到该位置后；5.重复步骤2~5。 java程序： public static int[] InsertionSort(int[] ary) { int temp = 0; for (int i = 0; i &lt; ary.length; i++) { for (int j = i; j &gt; 0; j--) { if(ary [j]&lt;ary [j-1]) { temp = ary [j]; ary [j]=ary [j-1]; ary[j-1]=temp; }else { break; } } } return ary; }算法总结：稳定 ；时间复杂度最优 O（n），最坏O（n^2）解释：若为已排序数组，第二层循环每次仅执行一次，最优时间复杂度O(n) 4. 希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。 个人理解：核心在于间隔序列的设定，既可以提前设定好间隔序列，也可以动态的定义间隔序列。 java程序: public static int[] ShellSort(int[] ary) { int num = ary.length/2; int temp = 0; while(num!=0) { for(int i=0;i&lt;ary.length-num;i++) { if(ary [i]&gt;ary [i+num]) { temp = ary [i+num]; ary [i+num]=ary [i]; ary[i]=temp; } } num = num/2; } return ary; }算法总结：不稳定；时间复杂度最优 O（n），最坏O（n^2） 5. 并归排序算法（mergeSort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。个人理解：就是将一串乱序的数组，在一个循环中，将数组依照长度，对半分开成两串，如果长度不为2，则继续分段，直到数组以2为单位的小数组，然后对小数组进行排序，再以4为单位排序，然后以8为单位排序，直到排序完成，需要在内存中开辟一片与原本数组大小相同的数组； 算法步骤：把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。 java代码： public static int[] mergeSort(int[] ary) { int len = ary.length; if (len &lt; 2) { return ary; } int middle = len / 2; int[] left = new int[middle]; int[] right = new int[len-middle]; for (int i = 0; i &lt; middle; i++) { left[i]=ary[i]; } for (int i = middle; i &lt; len; i++) { right[i-middle]=ary[i]; } return merge(mergeSort(left), mergeSort(right)); } @SuppressWarnings(&quot;null&quot;) public static int[] merge(int[]left,int[] right) { int[] result = new int[left.length+right.length]; int i = 0; int left_Pointer = 0; int right_Pointer = 0; while (left_Pointer&lt;left.length &amp;&amp; right_Pointer&lt;right.length) { if (left[left_Pointer] &lt;= right[right_Pointer]) { result [i]= left[left_Pointer]; left_Pointer++; i++; } else { result[i] = right[right_Pointer]; right_Pointer++; i++; } } while (left_Pointer&lt;left.length) { result [i]= left[left_Pointer]; left_Pointer++; i++;} while (right_Pointer&lt;right.length) { result[i] = right[right_Pointer]; right_Pointer++; i++;} return result; }个人总结：关于这个并归排序算法，参考了一些晚上c语言的逻辑，采用的递归的方法，对数组分成2长度的小段，并编写逻辑，使其返回的时候排序；算法中比较难的一点，就是要使用堆栈的方法，而本程序中，使用标记指针的方法，模拟了出栈的方法和入栈的方法，并未改变数组的长度； 算法总结:稳定；和选择排序一样（选择排序时间复杂度n^2），归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间 6. 快速排序（Quick Sort）原理：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。步骤：从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 java程序： 算法：不稳定，时间复杂度最好 O（n log2n），最差O(n^2) 7. 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。个人理解：将乱序的数组按原本的顺序存放在完全二叉树中，按照堆的特性，父结点比叶结点大，从底层到高层，再值大的点往根结点推，继而将根结点与最后的结点交换顺序，用此法循环，直到顺序排列完成算法步骤：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 算法：不稳定，时间复杂度最好 O（n log2n），最差O（n log2n） 8. 计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。个人理解：这个算法关键在于对输入数据的局限性，原本数组最大值与最小值差值太大会造成内存空间的浪费，适合数值集中的数组进行排序 算法步骤：找出待排序的数组中最大和最小的元素；统计数组中每个值为i的元素出现的次数，存入数组C的第i项；对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 算法：稳定，时间复杂度为 O（n+k） ，比其他比较算法都快 9. 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。个人理解：算法步骤：设置一个定量的数组当作空桶；遍历输入数据，并且把数据一个一个放到对应的桶里去；对每个不是空的桶进行排序；从不是空的桶里把排好序的数据拼接起来。 算法：稳定，桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10. 基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。个人理解：首先对个位数排序，在对十位数进行排，以此类推到最高位算法步骤：取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）； 算法：稳定，基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 参考博客：https://www.cnblogs.com/onepixel/articles/7674659.html（个人十分推荐去看这篇博客，有详细的动图，十分容易理解与掌握，强推！！！！）","categories":[],"tags":[]},{"title":"使用hexo与GitHub仓库初步搭建博客","slug":"使用hexo与GitHub仓库初步搭建博客","date":"2019-06-28T17:37:10.000Z","updated":"2019-07-11T17:49:29.285Z","comments":true,"path":"2019/06/29/使用hexo与GitHub仓库初步搭建博客/","link":"","permalink":"https://zhj1988.github.io/2019/06/29/使用hexo与GitHub仓库初步搭建博客/","excerpt":"简介：本人初学博客搭建，操作系统是window。在这些综合一下自己搭建博客过程遇到的问题，分享给有个我一样困惑的人。如果有错误欢迎指正。（完善中） 本次搭建过程可分为三部分 第一部分 环境配置 第二部分 hexo与github仓库连接 第三部分 更换博客主题","text":"简介：本人初学博客搭建，操作系统是window。在这些综合一下自己搭建博客过程遇到的问题，分享给有个我一样困惑的人。如果有错误欢迎指正。（完善中） 本次搭建过程可分为三部分 第一部分 环境配置 第二部分 hexo与github仓库连接 第三部分 更换博客主题 第一部分 环境配置 安装Gitwindows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。linux：需要一行代码。**sudo apt-get install git**git –version 查看版本 安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。windows：nodejs选择LTS版本linux： sudo apt-get install nodejssudo apt-get install npm使用node -v npm -v查看版本 安装hexo前面git和nodejs安装好后，就可以安装hexo了，先创建一个文件夹blog，在终端cd到这个文件夹下 。输入命令：**npm install -g hexo-cli**依旧用hexo -v查看一下版本接下来初始化一下hexo hexo init看到“Start blogging with Hexo！”即初始化成功接下来 输入npm install，安装所需要的组件输入hexo g，首次体验Hexo输入hexo s，开启服务器，访问该网址localhost:4000，看到生成的博客了。第一部分到此结束整体没有什么问题，按着教程顺序，window只需安装软件跟在命令行输入命令即可。 第二部分 hexo与github仓库连接 在github自己GitHub账号中创建一个项目项目必须要遵守格式：账户名.github.io（这个非常重要！！！） 生成ssh添加到github回到你的git bash中，或者继续用命令行cd到blog的文件夹 git config –global user.name “yourname” git config –global user.email “youremail”这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。可以用以下两条，检查一下你有没有输对 git config user.name git config user.email然后创建SSH,一路回车**ssh-keygen -t rsa -C &quot;youremail&quot;**这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹.而后在GitHub的setting中（鼠标移到右上角头像），找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。在gitbash中，查看是否成功 ssh -T git@github.com 将hexo部署到GitHub在你的blog文件夹中找到配置文件 _config.yml，翻到最后，修改为 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master注意没有repo，brach可以直接复制，后边type / repo / branch，冒号后面一定要加一个空格，我使用的Notepad++修改，修改后记得保存。然后安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub，在命令行中执行： npm install hexo-deployer-git –save安装完成后启动hexo： hexo clean hexo generate hexo deploy在浏览器打开 https://YourgithubName.github.io/ 后看到hexo就代表成功了。运行： hexo new “第一篇博客” hexo clean hexo g hexo d就可以看到更新的博客了，第二部分也到此结束。 第三部分 hexo blog编写小技巧layout（布局）：Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 默认使用的是post这个布局，也就是在source文件夹下的_post里面。hexo new [layout] &lt;title&gt; 使用pagehexo new page board系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是http://xxx.xxx/board 使用draft（草稿） hexo new draft newpage这样会在source/_draft中新建一个newpage.md文件，预览草稿，在本地端口中开启服务预览。 hexo server --draft如果你的草稿文件写完了，想要发表到post中，就会自动把newpage.md发送到post中 hexo publish draft newpage 第四部分 hexo blog 主题设置与布局##参考博客来源： https://blog.csdn.net/sinat_37781304/article/details/82729029","categories":[],"tags":[]}]}