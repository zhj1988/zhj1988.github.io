<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Spring Boot 缓存应用——ehcache | ZHuanJ——blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot 缓存应用——ehcache">
<meta property="og:url" content="https://zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/index.html">
<meta property="og:site_name" content="ZHuanJ——blog">
<meta property="og:description" content="简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-09-09T15:39:46.182Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Boot 缓存应用——ehcache">
<meta name="twitter:description" content="简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项">
  
    <link rel="alternate" href="zhj1988.github.io/atom.xml" title="ZHuanJ——blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="zhj1988.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="zhj1988.github.io/" id="logo">ZHuanJ——blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="zhj1988.github.io/">Home</a>
        
          <a class="main-nav-link" href="zhj1988.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="zhj1988.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhj1988.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring-Boot-缓存应用——ehcache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/" class="article-date">
  <time datetime="2019-09-09T14:45:36.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring Boot 缓存应用——ehcache
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介：时隔两个月，终于重新再记录自己的博客了，在做项目的途中不断汇聚零星的知识点，是时候整理一下了，对于之后项目或者学习中碰的知识，保持记录；进入正题，本篇博客记录一下关于缓存知识，使用缓存可以减少网络流量的时候，在客户端保存可重用性高的流量，但同时也会牺牲一部分性能，不同的缓存也适应不同的情况，本篇就先行介绍ehcache这个在SpringBoot 中应用即简单，入门快的模式的，下文就结合我在项目中的应用，对ehcache做一个介绍；</p>
<a id="more"></a>
<h2 id="本篇文章分为两个部分学习"><a href="#本篇文章分为两个部分学习" class="headerlink" title="本篇文章分为两个部分学习"></a>本篇文章分为两个部分学习</h2><p>一、原理分析<br>二、实际应用</p>
<hr>
<h2 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a>一、原理分析</h2><p>1.缓存的由来  </p>
<p>缓存要解决的问题：一个程序的瓶颈在于数据库，我们也知道内存的速度是大大快于硬盘的速度的。当我们需要重复地获取相同的数据的时候，我们一次又一次的请求数据库或者远程服务，导致大量的时间耗费在数据库查询或者远程方法调用上，导致程序性能的恶化，这便是数据缓存要解决的问题。</p>
<p>2.缓存的分类</p>
<p>类似的缓存技术有：Redis、EhCache、Guava等，现在一般常用的为Redis。</p>
<h2 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h2><p>我们从一个简单的例子入手：前端发送 用户手机获取验证码的请求；后端发送验证码并保存在缓存中（限时五分钟）；前端登陆，用户填写验证码发送会后台；后台比较验证码是否存在，以及验证码是否与缓存一致；完成验证操作。  </p>
<p>1.首先很好理解，缓存作为一个暂时存在的存储结构，保存一些时间限制的东西，当然同理也可以通过保存数据库，查询校验的方式来实现同等操作，但是缓存结构减少了删除操作，个人理解将内存负担又客户端来承受，扯回到实际应用中，缓存中保存是以Map中等同的&lt;key,value&gt;,一对一的映射进行存储，这样即可分辨出验证码对应登陆手机号是否一致；</p>
<p>2.介绍完毕，首先在SprinpBoot中pom.xml中添加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>3.在启动类即引导类上 添加注解@EnableCaching  （有些版本不需要添加）</p>
<p>4.缓存在ehcache中的value 对象需要引用接口序列化  implements Serializable</p>
<p>5.在resource路劲下添加ehcache配置文件。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;  
         updateCheck=&quot;false&quot;&gt;
         &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot; /&gt;  
    &lt;defaultCache  
            eternal=&quot;false&quot;  
            maxElementsInMemory=&quot;1000&quot;  
            overflowToDisk=&quot;false&quot;  
            diskPersistent=&quot;false&quot;  
            timeToIdleSeconds=&quot;0&quot;  
            timeToLiveSeconds=&quot;100&quot;  
            memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt;  

    &lt;cache  
            name=&quot;cache&quot;  
            eternal=&quot;false&quot;   #是否永久缓存
            maxElementsInMemory=&quot;100&quot;  
            overflowToDisk=&quot;false&quot;  
            diskPersistent=&quot;false&quot;  
            timeToIdleSeconds=&quot;0&quot;   #最大闲置时间
            timeToLiveSeconds=&quot;30&quot;  #最大缓存时间
            memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt;  
&lt;/ehcache&gt;</code></pre><p>具体属性参考下文：</p>
<p>(1).diskStore： 为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：  　　　　<br>user.home – 用户主目录<br>user.dir  – 用户当前工作目录<br>java.io.tmpdir – 默认临时文件路径<br>(2).defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。<br>(3).cache：自定缓存策略，为自定义的缓存策略。参数解释如下：<br>cache元素的属性：<br>name：缓存名称<br>maxElementsInMemory：内存中最大缓存对象数<br>maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大<br>eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false<br>overflowToDisk：true表示当内存缓存的对象数目达到了maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。<br>diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。<br>diskPersistent：是否缓存虚拟机重启期数据<br>diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒<br>timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态<br>timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。    timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义<br>memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。  </p>
<p>6.创建配置类config</p>
<pre><code>@Configuration
@EnableCaching
public class EhCacheConfig {

    @Value(&quot;${spring.cache.ehcache.config}&quot;)
    private String ehCacheCongifPath;


    @Bean
    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean() {
        EhCacheManagerFactoryBean cacheManagerFactoryBean = new EhCacheManagerFactoryBean();
        System.out.println(ehCacheCongifPath);
        cacheManagerFactoryBean.setConfigLocation(new ClassPathResource(ehCacheCongifPath));
        cacheManagerFactoryBean.setShared(true);
        //如果 Factory 自己手动实列化，需要 执行afterPropertiesSet()方法，因为这是方法是 初始化 类使用的
        //如果Factory 由Spring 容器 创建 ，容器初始化完成后 spring 会去执行这个方法。
        //cacheManagerFactoryBean.afterPropertiesSet();
        // 初始化 读取配置文件,
        return cacheManagerFactoryBean;
    }

    @Bean
    public CacheManager compositeCacheManager(@Autowired EhCacheManagerFactoryBean factoryBean) {
        //RedisCacheManager redisCacheManager = getRedisCacheManager(redisTemplate);
        //GuavaCacheManager guavaCacheManager = getGuavaCacheManager();
        EhCacheCacheManager ehCacheCacheManager = ehCacheCacheManager(factoryBean);
        CompositeCacheManager cacheManager = new CompositeCacheManager(ehCacheCacheManager);
        cacheManager.setFallbackToNoOpCache(true);
        cacheManager.afterPropertiesSet();
        return cacheManager;
    }


    private EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean factoryBean) {
        //由于自己实列化EhCacheManager 需要执行 手动初始化 方法。
        EhCacheCacheManager ehCacheCacheManager = new EhCacheCacheManager(factoryBean.getObject());
        //初始化
        ehCacheCacheManager.initializeCaches();
        return ehCacheCacheManager;
    }

}</code></pre><p>7.进入实际应用，在service实现类中，在类或者方法上添加注解（不同地方表示注解范围不同）</p>
<p>介绍一下三个主要的注解<br>@CachePut表示缓存新添加的数据或者更新的数据到缓存中；<br>@CacheEvict表示清除缓存；<br>@Cacheable表示添加数据到缓存中，如果缓存中已有对应的值，则不更新；  </p>
<p>使用注解时候注意地方<br>example1（存缓存）：  </p>
<pre><code>@CachePut(value=&quot;verifications&quot;,key=&quot;#phone&quot;)
    public Verification createVerification(String phone) {
        Verification verification = new Verification();
        verification.setPhone(phone);
        verification.setCheckCode(&quot;1234&quot;);
        System.out.println(verification.toString());
        return verification;
    }</code></pre><p>首先注解的参数#phone 必须为方法的参数；<br>其次value=“name” 为ehcache中 name的命名（好像可以自己命名，待测试）；<br>最后缓存保持的值，为方法返回的值，没错，就是方法返回的值，如果你返回对象，缓存即为对象，如果是String数据，缓存即为String；  </p>
<p>example2：  </p>
<pre><code>@Cacheable(value = &quot;verifications&quot;,key = &quot;#phone&quot;)
    public Verification checkCode(String phone) {
        return null;
    }</code></pre><p>在此例子中，若缓存已有保存数据，则返回缓存中的值，若无，则返回null；</p>
<p>综上，ehcache的实际应用还有注意点以及介绍完毕，当然关于其更多的应用则是应用在数据库查询上，当添加注解后，其方法执行，若是方法查询的参数一致，则不会访问数据库，直接返回缓存中的数据；</p>
<p>参考博客：<br>1.<a href="https://blog.csdn.net/open_yu/article/details/80654555" target="_blank" rel="noopener">https://blog.csdn.net/open_yu/article/details/80654555</a><br>2.<a href="https://blog.csdn.net/smartdt/article/details/78733203" target="_blank" rel="noopener">https://blog.csdn.net/smartdt/article/details/78733203</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/" data-id="ck11j9ux9000bxwuvsm84zhv1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微信公众号网页授权与模板消息发送
        
      </div>
    </a>
  
  
    <a href="zhj1988.github.io/2019/08/07/html与js-学习笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">html与js 学习笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/">微信公众号网页授权与模板消息发送</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/">Spring Boot 缓存应用——ehcache</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/07/html与js-学习笔记/">html与js 学习笔记</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/06/bootstrap-学习记录/">bootstrap 学习记录</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/07/24/SpringBoot结构分层解析/">SpringBoot结构分层解析 </a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZHuanJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="zhj1988.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="zhj1988.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="zhj1988.github.io/fancybox/jquery.fancybox.css">
  <script src="zhj1988.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="zhj1988.github.io/js/script.js"></script>



  </div>
</body>
</html>