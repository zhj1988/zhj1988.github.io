<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>微信公众号网页授权与模板消息发送 | ZHuanJ——blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。本文章共分为三部分： 一、微信网页授权登陆二、公众号模板消息发送三、微信分享">
<meta property="og:type" content="article">
<meta property="og:title" content="微信公众号网页授权与模板消息发送">
<meta property="og:url" content="https://zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/index.html">
<meta property="og:site_name" content="ZHuanJ——blog">
<meta property="og:description" content="简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。本文章共分为三部分： 一、微信网页授权登陆二、公众号模板消息发送三、微信分享">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/zhj1988/markdown/master/wx00001.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/zhj1988/markdown/master/wx00002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhj1988/markdown/master/wx123456789.png">
<meta property="og:updated_time" content="2019-09-26T07:06:57.693Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微信公众号网页授权与模板消息发送">
<meta name="twitter:description" content="简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。本文章共分为三部分： 一、微信网页授权登陆二、公众号模板消息发送三、微信分享">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhj1988/markdown/master/wx00001.PNG">
  
    <link rel="alternate" href="zhj1988.github.io/atom.xml" title="ZHuanJ——blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="zhj1988.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="zhj1988.github.io/" id="logo">ZHuanJ——blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="zhj1988.github.io/">Home</a>
        
          <a class="main-nav-link" href="zhj1988.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="zhj1988.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhj1988.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-微信公众号网页授权与模板消息发送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/" class="article-date">
  <time datetime="2019-09-25T08:57:10.000Z" itemprop="datePublished">2019-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      微信公众号网页授权与模板消息发送
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介：在做项目的过程中，需要接触到微信公众号登陆以及微信公众号的模板消息发送，微信分享今天基于这三部分，做一个小小的总结。<br>本文章共分为三部分：</p>
<h3 id="一、微信网页授权登陆"><a href="#一、微信网页授权登陆" class="headerlink" title="一、微信网页授权登陆"></a>一、微信网页授权登陆</h3><h3 id="二、公众号模板消息发送"><a href="#二、公众号模板消息发送" class="headerlink" title="二、公众号模板消息发送"></a>二、公众号模板消息发送</h3><h3 id="三、微信分享"><a href="#三、微信分享" class="headerlink" title="三、微信分享"></a>三、微信分享</h3><a id="more"></a>
<h2 id="微信网页授权登陆"><a href="#微信网页授权登陆" class="headerlink" title="微信网页授权登陆"></a>微信网页授权登陆</h2><h3 id="1-微信开发文档"><a href="#1-微信开发文档" class="headerlink" title="1.微信开发文档"></a>1.微信开发文档</h3><p>首先一定要先了解清除微信开发文档，明白传参的含义以及各自的差别；</p>
<p>开发文档地址：<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</a></p>
<p>比如其中的  </p>
<p>1）关于网页授权的两种scope的区别说明</p>
<p>a、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>b、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>2）关于网页授权access_token和普通access_token的区别</p>
<p>a、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>b、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<p>3）如果是多应用联合，则需注意UnionID机制，ex：如淘宝，支付宝这关联账户，unionid也应用于来区分用户的唯一性  </p>
<h3 id="2-流程（非静默授权）"><a href="#2-流程（非静默授权）" class="headerlink" title="2.流程（非静默授权）"></a>2.流程（非静默授权）</h3><p>1）、引导用户进入授权页面同意授权，获取code</p>
<p>2）、通过code换取网页授权access_token（与基础支持中的access_token不同）</p>
<p>3）、如果需要，开发者可以刷新网页授权access_token，避免过期</p>
<p>4）、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p>
<p>关于这四个步骤相信熟读微信开发文档的伙伴肯定很熟悉，我就讲解一下其中的一些细节部分； </p>
<p>第一个，是关于前后端分离的项目怎么分配工作，根据微信开发文档，access_token不能暴露在客户端，因此1获取code的工作由前端完成；2，3，4三个步骤在后台完成工作，拉取用户信息后，存入数据库并返回给前端；</p>
<p>第二个，相信很多伙伴一开始没有微信公众号可以测试（如果公司有提供测试当我没说），微信公众号申请又有点繁琐，所以我推荐一开始开发使用，微信公众号平台接口测试：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" title="微信公众平台接口测试" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a> 只需要一个微信号，即可开始简便开发，关于测试平台与正式微信公众号平台的细微差别，我会在讲解的过程中提及；</p>
<h3 id="3-具体实现过程"><a href="#3-具体实现过程" class="headerlink" title="3.具体实现过程"></a>3.具体实现过程</h3><p>ok，我们现在正式从四个步骤开始<br><strong>第一步</strong> 获取code<br>前端在进入首页时，在js中先向微信发送请求：<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a><br>这一步很简单，但是涉及配置的东西较多；  </p>
<p>1.APPID：测试号中，很容易就找到，正式的微信公众号，找不到的话就百度吧，这个没什么好说的  </p>
<p>2.scope：作用域，第一点的微信开发文档也说过了，需要用户点击授权登陆，此时scope=snsapi_userinfo；  </p>
<p>3.state:此参数相当与传参的作用，表明是由此网页发送的，作为一个身份识别，例如用户点击授权登陆之后，会带着从微信官方获得的code以及你发送的state返回至回调地址，如果是多网页不同的登陆操作，可以通过设置state不同来对应处理code（博主对前端也不是特别熟悉，此处猜测state其作用），如果只是简单的登陆授权，state不设置或者为1234即可；  </p>
<p>4.redirect_uri：回调地址，其作用为，当你发送请求后，微信用户点击确认后跳转的地址，查看响应头可知，回调地址必须为text-html，不能为接口；表现形式为：url？code=XXXX&amp;state=XXX；另外，最重要的就是公众号的配置：<br>a）测试号配置：在此处配置你的域名<br><img src="https://raw.githubusercontent.com/zhj1988/markdown/master/wx00001.PNG" alt="测试号配置"></p>
<p>b）微信公众号配置：<br>在功能设置中设置</p>
<p><img src="https://raw.githubusercontent.com/zhj1988/markdown/master/wx00002.png" alt><br>同时一定要下载这个文件  </p>
<p><img src="https://raw.githubusercontent.com/zhj1988/markdown/master/wx123456789.png" alt><br>并配置在你项目根目录下（ =_= 简单的解释就是，当你的项目运行时候，路径：你的域名/文件名，即可访问到该文件，我用的是springboot 只需要在mvc配置类中做一个静态资源的映射即可，或者在application.yml中添加配置路径即可，如果使用的是tomcat或者apache 不需有项目配置路径，丢到相应的webapp或者html文件夹下即可，具体可自行上网搜索）</p>
<p>至此第一步实现过程以及配置过程结束；</p>
<p><strong>第二步</strong>后台获取用户信息</p>
<p>1.添加pom依赖</p>
<pre><code> &lt;dependency&gt;
    &lt;groupId&gt;com.github.liyiorg&lt;/groupId&gt;
    &lt;artifactId&gt;weixin-popular&lt;/artifactId&gt;
    &lt;version&gt;2.8.17&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>2.获取用户信息</p>
<pre><code> public static Map&lt;String,Object&gt; goToIndex( String code,Integer id){
    Map&lt;String,Object&gt; map =new HashMap&lt;&gt;();
    map.put(&quot;code&quot;,code);
    System.out.println(&quot;code: &quot;+code);

    if(code==null||&quot;&quot;.equals(code)){
        // return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;code为空&quot;);
        map.put(&quot;error&quot;,&quot;code为空&quot;);
        return map;
    }

    SnsToken snsToken = SnsAPI.oauth2AccessToken(appID, appSecret, map.get(&quot;code&quot;).toString());
    String errcode = snsToken.getErrcode();
    if(errcode!=null&amp;&amp;!&quot;&quot;.equals(errcode)){
        //return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;微信获取出错&quot;);
        map.put(&quot;error&quot;,&quot;微信获取出错&quot;);
        return map;
    }
    User user = SnsAPI.userinfo(snsToken.getAccess_token(), snsToken.getOpenid(), &quot;zh_CN&quot;,1);
    String errcode1 = user.getErrcode();
    if(errcode1!=null&amp;&amp;!&quot;&quot;.equals(errcode1)){
        map.put(&quot;error&quot;,&quot;微信获取信息出错&quot;);
        return map;
        //return new JsonResultNew&lt;&gt;(MyBusinessEnum.BUSINESS_ERROR,&quot;微信获取信息出错&quot;);
    }
    return map;
}</code></pre><p>注意配置appid，appSecret（测试号可以直接看，微信公众号appid也可以查到，但是appsecret由于安全问题，在公众号内并不保持，具体就要问运营者了）</p>
<p>以上只是简单使用access_token获取用户信息；<br>SnsToken snsToken = SnsAPI.oauth2AccessToken(appID, appSecret, map.get(“code”).toString());<br>如果为非静默授权，你可以获得一个refresh_token 用于刷新access_token。<br>snsToken.getRefresh_token();<br>参考微信开发文档： </p>
<hr>
<p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。</p>
<p>请求方法</p>
<p>获取第二步的refresh_token后，请求以下链接获取access_token：<br><a href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a><br>appid    是    公众号的唯一标识<br>grant_type    是    填写为refresh_token<br>refresh_token    是    填写通过access_token获取到的refresh_token参数<br>以上参数均可获得；</p>
<hr>
<p>参考SnsToken源码中也有刷新方法：</p>
<pre><code>public static SnsToken oauth2RefreshToken(String appid, String refresh_token) {
       HttpUriRequest httpUriRequest = RequestBuilder.post().setUri(&quot;https://api.weixin.qq.com/sns/oauth2/refresh_token&quot;).addParameter(&quot;appid&quot;, appid).addParameter(&quot;refresh_token&quot;, refresh_token).addParameter(&quot;grant_type&quot;, &quot;refresh_token&quot;).build();
       return (SnsToken)LocalHttpClient.executeJsonResult(httpUriRequest, SnsToken.class);
   }</code></pre><p>（不得不感慨，Java确实方便，不少现成的jar包提供给他人）</p>
<p>记得保存refresh_token 用于之后用户登陆的刷新；</p>
<p>综上，是不是觉得获取微信用户信息十分方便，然而其中也有很多曲折，一路摸索过来，反而是使用code获取用户信息这一复杂的步骤比较轻松，更多的时间在配置文件，以前端的测试；对了还有两个很重要的点，使用微信web开发工具测试授权登陆时候，微信用户一定要先关注测试号（如果是正式公众号则会弹窗关注该公众号）；其次前端项目，必须上传到服务器测试授权登陆，本地不能测试（=_= 不过回调地址能理解的话，就不会在本地测试授权登陆了）</p>
<h2 id="公众号消息模板发送"><a href="#公众号消息模板发送" class="headerlink" title="公众号消息模板发送"></a>公众号消息模板发送</h2><h3 id="一-微信开发文档"><a href="#一-微信开发文档" class="headerlink" title="一.微信开发文档"></a>一.微信开发文档</h3><p>万变不离其宗，首先我们先来看下微信开发文档中对消息模板的介绍：  </p>
<p>1、所有服务号都可以在功能-&gt;添加功能插件处看到申请模板消息功能的入口，但只有认证后的服务号才可以申请模板消息的使用权限并获得该权限；<br>2、需要选择公众账号服务所处的2个行业，每月可更改1次所选行业；<br>3、在所选择行业的模板库中选用已有的模板进行调用；<br>4、每个账号可以同时使用25个模板。<br>5、当前每个账号的模板消息的日调用上限为10万次，单个模板没有特殊限制。<br>上述介绍了什么为消息模板，首先选择公众号所属行业，再从模板需要从模板库下载，而如果需要符合自身的消息模板，则需要申请（审核需要5——7天）  </p>
<p>关于接口文档，请注意：  </p>
<pre><code>1、模板消息调用时主要需要模板ID和模板中各参数的赋值内容；  
2、模板中参数内容必须以&quot;.DATA&quot;结尾，否则视为保留字；  
3、模板保留符号&quot;{{ }}&quot;。  </code></pre><p>上诉表明了参数的规则</p>
<h3 id="二-实现过程"><a href="#二-实现过程" class="headerlink" title="二.实现过程"></a>二.实现过程</h3><p>1.配置相应的appid，appsecret，templateId（模板id）<br>2.编程：<br>1）添加pom依赖</p>
<pre><code>&lt;!--微信模版消息推送三方sdk--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt;
    &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>2)工具类中：</p>
<pre><code>public static Map&lt;String,Object&gt; push1(String templateId, StudyClock studyClock){
    Map&lt;String,Object&gt;map = new HashMap&lt;&gt;();
    //1，配置
    WxMpService wxMpService = build2();
    //2,推送消
    WxMpTemplateMessage templateMessage = build1(templateId,openid);

    //3,如果是正式版发送模版消息，这里需要配置你的信息
    templateMessage.addData(new WxMpTemplateData(&quot;first&quot;, &quot;提醒内容&quot;, &quot;#85ffc3&quot;));
    templateMessage.addData(new WxMpTemplateData(&quot;remark1&quot;, &quot;提醒内容&quot;, &quot;#85ffc3&quot;));

    return send(wxMpService,templateMessage);
}



private static WxMpTemplateMessage build1(String templateId, String openid ){
    //2,推送消息
    WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder()
            .toUser(openid)//要推送的用户openid
            .templateId(templateId)//模版id
            .url(&quot;url&quot;)//点击模版消息要访问的网址
            .build();
    return templateMessage;
}

private static WxMpService build2( ){
    //2,推送消息
    WxMpInMemoryConfigStorage wxStorage = new WxMpInMemoryConfigStorage();
    wxStorage.setAppId(appID);
    wxStorage.setSecret(appSecret);
    WxMpService wxMpService = new WxMpServiceImpl();
    wxMpService.setWxMpConfigStorage(wxStorage);
    return wxMpService;
}

private static Map&lt;String,Object&gt; send(WxMpService wxMpService,WxMpTemplateMessage templateMessage ){
    Map&lt;String,Object&gt;map = new HashMap&lt;&gt;();
    try {
        wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);
        map.put(&quot;msg&quot;,&quot;微信提醒发送成功&quot;);
    } catch (Exception e) {
        System.out.println(&quot;推送失败：&quot; + e.getMessage());
        map.put(&quot;msg&quot;,&quot;推送失败：&quot; + e.getMessage());
        e.printStackTrace();

    }finally {
        return map;
    }

}</code></pre><p>上述程序已基本总结完毕，openid为微信用户的openid，用户发送至相应的微信账号（这个可从第一步获得）</p>
<p>除了运用现成的jar包，也可以使用HttpClient等jar包，直接向微信官方请求接口，使用JsonObject 接收返回参数，再做相应的判断也即可；</p>
<h2 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h2><h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><p>当我们在公众号的页面时候，点击右上角即有一个分享功能，分享给好友，分享给朋友圈，前端就会生成相应的连接，此时就运用到了微信分享功能的一些知识；<br>首先声明，我只是一名后端小程序员，对于前端的很多事情并不理解，所以对于前端的一些布置就简单掠过；</p>
<h3 id="二-配置环境"><a href="#二-配置环境" class="headerlink" title="二.配置环境"></a>二.配置环境</h3><p>在微信公众号平台中，设置js安全域名 ；以及部署的服务器ip添加到ip白名单</p>
<h3 id="三-主要过程"><a href="#三-主要过程" class="headerlink" title="三.主要过程"></a>三.主要过程</h3><p>前端生成分享链接，需要后台生成签名以及其他数据；</p>
<p>主要过程：<br>1.获取access_token；<br>2.获取jsapi_ticket；<br>3.生成签名;<br>4.把签名和随机串和appid和时间戳发回给前端；</p>
<p>access_token每天获取有上限，而且有效期为7200s 两个小时，所以需要在后台缓存该数据（如果不同或者嫌麻烦就存在数据库吧）<br>这里我使用的是session缓存，<strong>说一下关于缓存的坑（以下仅关于springboot）</strong>；  
1）首先设置session过期时间，在springboot 配置文件中设置即可server.servlet.session.timeout=5400s(一个半小时)，设置完后你会发现，过了几秒，缓存就不见了，并不像配置文件中所诉一下；此处出现第一个坑，原因为springBoot2.x版本以上，过期时间的写法作了调整，所以更改为server.servlet.session.timeout=PT90M<br>具体写法参考： <a href="https://blog.csdn.net/heart_mine/article/details/89176410" target="_blank" rel="noopener">https://blog.csdn.net/heart_mine/article/details/89176410</a></p>
<p>简述一下：<br>字符串类似数字有正负之分,默认正,负以’-‘开头,紧接着’P’,下面所有字母都不区分大小写:<br>‘D’ – 天<br>‘H’ – 小时<br>‘M’ – 分钟<br>‘S’ – 秒<br>字符’T’是紧跟在时分秒之前的，每个单位都必须由数字开始,且时分秒顺序不能乱,比如:P2DT3M5S,P3D,PT3S，PT3M2S 等于 -PT-3M-2S</p>
<p>2）设置完过期时间，本来兴高采烈的，但是测试的时候发现，session的过期时间已经到了，但是仍然可以获取到数据，而不用再存入缓存，此时我懵逼了，再三测试以及联想ehcache缓存一些知识，我终于知道怎么填这个坑了；<br><strong>session的过期时间，即使活跃时间，简单解释即，当你设置一分钟的过期时间，你在一分钟内不访问缓存，缓存即失效，而当你在一分钟内访问缓存，过期时间即会被刷新</strong> 至此session过期时间的神秘面纱终于被揭露。</p>
<p>3）综上，由于活跃时间的设计，access_token也会面临在缓存中存在而使用其请求的时候失效的问题，所以我们可以设置一个时间戳，在存入缓存的同时，也将时间戳存入，当取出缓存时候，对比现在的时间戳，如果已经过了失效时间，即重新请求，这么简单的算法我就不贴出来了，关于时间戳的问题，大家也可以百度搜索即可。</p>
<h3 id="四-代码编写"><a href="#四-代码编写" class="headerlink" title="四.代码编写"></a>四.代码编写</h3><p>首先，关于生成的签名，由于要经过相应的算法加密，所以对生成的算法签名验证问题，我推荐微信官方一个验证网站；<br>链接：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</a></p>
<p>代码如下：</p>
<pre><code>@GetMapping(value = &quot;/share&quot;)
@ResponseBody
public Map&lt;String,Object&gt; share(HttpServletRequest request){
    Map&lt;String, Object&gt;map = new HashMap&lt;&gt;();
    HttpSession session=request.getSession();
    String url =request.getParameter(&quot;url&quot;);
    String accessToken =&quot;&quot;;
    String jsapi_ticket =&quot;&quot;;
    accessToken = wxUtil.getAccessToken();
    session.setAttribute(&quot;accessToken&quot;,accessToken);
    System.out.println(&quot;accessToken保存至缓存中&quot;);
    jsapi_ticket =  wxUtil.getTicket(accessToken);
    session.setAttribute(&quot;jsapi_ticket&quot;,jsapi_ticket);
    System.out.println(&quot;jsapi_ticket保存至缓存中&quot;);

    //3、时间戳和随机字符串
    String noncestr = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 16);//随机字符串
    String timestamp = String.valueOf(System.currentTimeMillis() / 1000);//时间戳
    System.out.println(&quot;accessToken:&quot;+accessToken+&quot;\njsapi_ticket:&quot;+jsapi_ticket+&quot;\n时间戳：&quot;+timestamp+&quot;\n随机字符串：&quot;+noncestr);


    //4、将参数排序并拼接字符串
    String str = &quot;jsapi_ticket=&quot;+jsapi_ticket+&quot;&amp;noncestr=&quot;+noncestr+&quot;&amp;timestamp=&quot;+timestamp+&quot;&amp;url=&quot;+url;

    //5、将字符串进行sha1加密
    String signature =SHA1(str);
    System.out.println(&quot;参数：&quot;+str+&quot;\n签名：&quot;+signature);
    map.put(&quot;appId&quot;,appID);
    map.put(&quot;timestamp&quot;,timestamp);
    map.put(&quot;noncestr&quot;,noncestr);
    map.put(&quot;signature&quot;,signature);
    return  map;

}


//以下为其他获取方法，大部分也是我从网上copy来的

public static String getAccessToken() {
    String access_token = &quot;&quot;;
    String grant_type = &quot;client_credential&quot;;//获取access_token填写client_credential
    String AppId=appID;//第三方用户唯一凭证
    String secret=appSecret;//第三方用户唯一凭证密钥，即appsecret
    //这个url链接地址和参数皆不能变
    String url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=&quot;+grant_type+&quot;&amp;appid=&quot;+AppId+&quot;&amp;secret=&quot;+secret;

    try {
        URL urlGet = new URL(url);
        HttpURLConnection http = (HttpURLConnection) urlGet.openConnection();
        http.setRequestMethod(&quot;GET&quot;); // 必须是get方式请求
        http.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        http.setDoOutput(true);
        http.setDoInput(true);
        System.setProperty(&quot;sun.net.client.defaultConnectTimeout&quot;, &quot;30000&quot;);// 连接超时30秒
        System.setProperty(&quot;sun.net.client.defaultReadTimeout&quot;, &quot;30000&quot;); // 读取超时30秒
        http.connect();
        InputStream is = http.getInputStream();
        int size = is.available();
        byte[] jsonBytes = new byte[size];
        is.read(jsonBytes);
        String message = new String(jsonBytes, &quot;UTF-8&quot;);
        JSONObject demoJson =  JSONObject.parseObject(message);
        System.out.println(&quot;JSON字符串：&quot;+demoJson);
        access_token = demoJson.getString(&quot;access_token&quot;);
        is.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return access_token;
}

public static String getTicket(String access_token) {
    String ticket = null;
    String url = &quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&quot;+ access_token +&quot;&amp;type=jsapi&quot;;//这个url链接和参数不能变
    try {
        URL urlGet = new URL(url);
        HttpURLConnection http = (HttpURLConnection) urlGet.openConnection();
        http.setRequestMethod(&quot;GET&quot;); // 必须是get方式请求
        http.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        http.setDoOutput(true);
        http.setDoInput(true);
        System.setProperty(&quot;sun.net.client.defaultConnectTimeout&quot;, &quot;30000&quot;);// 连接超时30秒
        System.setProperty(&quot;sun.net.client.defaultReadTimeout&quot;, &quot;30000&quot;); // 读取超时30秒
        http.connect();
        InputStream is = http.getInputStream();
        int size = is.available();
        byte[] jsonBytes = new byte[size];
        is.read(jsonBytes);
        String message = new String(jsonBytes, &quot;UTF-8&quot;);
        JSONObject demoJson =  JSONObject.parseObject(message);
        System.out.println(&quot;JSON字符串：&quot;+demoJson);
        ticket = demoJson.getString(&quot;ticket&quot;);
        is.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return ticket;
}

public static String SHA1(String decript) {
    try {
        MessageDigest digest = java.security.MessageDigest.getInstance(&quot;SHA-1&quot;);
        digest.update(decript.getBytes());
        byte messageDigest[] = digest.digest();
        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        // 字节数组转换为 十六进制 数
        for (int i = 0; i &lt; messageDigest.length; i++) {
            String shaHex = Integer.toHexString(messageDigest[i] &amp; 0xFF);
            if (shaHex.length() &lt; 2) {
                hexString.append(0);
            }
            hexString.append(shaHex);
        }
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return &quot;&quot;;
}</code></pre><p>至此生成签名代码代码已结束；</p>
<p>总结：微信官方文档齐全，网上可借鉴模板也多，在开发过程中遇到困难，不要急于寻找其他方法，了解前因后果，才是解决困难的捷径；之后会将微信小程序，微信支付等其他相关知识再完善；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/" data-id="ck11jlkhe000iiouva3dn2d8r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Spring Boot 缓存应用——ehcache</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/">微信公众号网页授权与模板消息发送</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/">Spring Boot 缓存应用——ehcache</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/07/html与js-学习笔记/">html与js 学习笔记</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/06/bootstrap-学习记录/">bootstrap 学习记录</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/07/24/SpringBoot结构分层解析/">SpringBoot结构分层解析 </a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZHuanJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="zhj1988.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="zhj1988.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="zhj1988.github.io/fancybox/jquery.fancybox.css">
  <script src="zhj1988.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="zhj1988.github.io/js/script.js"></script>



  </div>
</body>
</html>