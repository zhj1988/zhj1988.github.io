<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>经典排序算法概述&amp;&amp;个人体会总结 | ZHuanJ——blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 （待完善）">
<meta property="og:type" content="article">
<meta property="og:title" content="经典排序算法概述&amp;&amp;个人体会总结">
<meta property="og:url" content="https://zhj1988.github.io/2019/06/30/程序经典排序算法个人体会与总结/index.html">
<meta property="og:site_name" content="ZHuanJ——blog">
<meta property="og:description" content="简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 （待完善）">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-14T12:27:02.228Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="经典排序算法概述&amp;&amp;个人体会总结">
<meta name="twitter:description" content="简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 （待完善）">
  
    <link rel="alternate" href="zhj1988.github.io/atom.xml" title="ZHuanJ——blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="zhj1988.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="zhj1988.github.io/" id="logo">ZHuanJ——blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="zhj1988.github.io/">Home</a>
        
          <a class="main-nav-link" href="zhj1988.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="zhj1988.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhj1988.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-程序经典排序算法个人体会与总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="zhj1988.github.io/2019/06/30/程序经典排序算法个人体会与总结/" class="article-date">
  <time datetime="2019-06-30T10:58:10.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      经典排序算法概述&amp;&amp;个人体会总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介：本次博客总结一下网上现存的十个排序算法，结合个人之前一些不理解的地方进行汇总，再使用java语言对算法逻辑复刻，同时对一些地方加入细节，如果有错误的地方，欢迎指正。 <strong>（待完善）</strong></p>
<a id="more"></a> 
<p>首先是关于稳定性解释：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。—–来自百度百科（十分好理解）  </p>
<h2 id="1-冒泡排序法（Bubble-Sort）"><a href="#1-冒泡排序法（Bubble-Sort）" class="headerlink" title="1. 冒泡排序法（Bubble Sort）"></a>1. 冒泡排序法（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。  </p>
<p>java程序：  </p>
<pre><code>public class sort {
static int[] ary = {2,1,3,45,12,56,88,44,1,2,6,7,89,3,45,44,72};
public static int[] BubbleSort(int[] ary) {
    for (int i = 0; i &lt; ary.length; i++) {
        boolean flag = true;
        for (int j = 0; j &lt; ary.length-i-1; j++) {
            int temp = 0;
            if(ary [j]&gt;ary [j+1]) {
                temp = ary [j+1];
                ary [j+1]=ary [j];
                ary[j]=temp;
                flag = false;
            }
        }
        if(flag) {
            System.out.println(&quot;数组长度:&quot;+ary.length );
            System.out.println(&quot;第&quot;+(i+1)+&quot;层外循环，数组已经排序完成&quot;);
            break;
        }
    }
    return ary;
}
public static void main(String[] arg) {
    int[] result = BubbleSort( ary );
    for (int i = 0; i &lt; result.length; i++) {
        System.out.print(result[i]);
        System.out.print(&quot; &quot;);
    }
}
}</code></pre><p>算法总结：稳定；时间复杂度：最优 O（n），最坏O（n^2），<strong>怎么最优解：</strong>第一层循环设定一个标志为true，在第二层循环，if判断是否交换数组元素时候，若交换则修改标志为false，第二层循环结束，若无交换，则标志任为false，此时写一个if判断，若为false，则break跳出循环，或者return退出方法。 </p>
<h2 id="2-选择排序法-Selection-sort"><a href="#2-选择排序法-Selection-sort" class="headerlink" title="2. 选择排序法(Selection-sort)"></a>2. 选择排序法(Selection-sort)</h2><p>选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<p><strong>个人理解</strong>：选择排序法，每次固定两层循环，将未排序的剩余元素一一进行比较，排序得出该序列上位置的最优解，所以时间复杂度固定不变。 </p>
<p>java程序：</p>
<pre><code>public static int[] SelectionSort(int[] ary) {
    int temp = 0;
    for (int i = 0; i &lt; ary.length; i++) {
        int num = i;
        for (int j = i; j &lt; ary.length-1; j++) {
            if(ary [num]&gt;ary [j+1]) {
                num = j+1;
            }
        }
        if(num!=i) {
            temp = ary [num];
            ary [num]=ary [i];
            ary[i]=temp;
        }
    }
    return ary;
}  </code></pre><p>算法总结：时间复杂度，最优O（n^2）最坏O（n^2）； 不稳定，解释：举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><p>插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>从第一个元素开始，该元素可以认为已经被排序 </p>
<p>算法步骤：<br>1.取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>2.如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>3.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>4.将新元素插入到该位置后；<br>5.重复步骤2~5。</p>
<p>java程序：  </p>
<pre><code>public static int[] InsertionSort(int[] ary) {
    int temp = 0;
    for (int i = 0; i &lt; ary.length; i++) {
        for (int j = i; j &gt; 0; j--) {
            if(ary [j]&lt;ary [j-1]) {
                temp = ary [j];
                ary [j]=ary [j-1];
                ary[j-1]=temp;
            }else {
                break;
            }
        }
    }
    return ary;
}</code></pre><p>算法总结：稳定 ；时间复杂度最优 O（n），最坏O（n^2）解释：若为已排序数组，第二层循环每次仅执行一次，最优时间复杂度O(n)</p>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。</p>
<p>个人理解：核心在于<strong>间隔序列的设定</strong>，既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p>
<p>java程序:  </p>
<pre><code>public static int[] ShellSort(int[] ary) {
    int num = ary.length/2;
    int temp = 0;
    while(num!=0) {
       for(int i=0;i&lt;ary.length-num;i++)  
       {  
           if(ary [i]&gt;ary [i+num]) {
               temp = ary [i+num];
            ary [i+num]=ary [i];
            ary[i]=temp;
           }
       }
       num = num/2;
    }
    return ary;
}</code></pre><p>算法总结：不稳定；时间复杂度最优 O（n），最坏O（n^2）  </p>
<h2 id="5-并归排序算法（mergeSort）"><a href="#5-并归排序算法（mergeSort）" class="headerlink" title="5. 并归排序算法（mergeSort）"></a>5. 并归排序算法（mergeSort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br>个人理解：就是将一串乱序的数组，在一个循环中，将数组依照长度，对半分开成两串，如果长度不为2，则继续分段，直到数组以2为单位的小数组，然后对小数组进行排序，再以4为单位排序，然后以8为单位排序，直到排序完成，需要在内存中开辟一片与原本数组大小相同的数组；  </p>
<p>算法步骤：<br>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。   </p>
<p>java代码：  </p>
<pre><code>public static int[] mergeSort(int[] ary) {
    int  len = ary.length;
    if (len &lt; 2) {
        return ary;
    }
    int middle = len / 2;
    int[]  left = new int[middle];
    int[]  right = new int[len-middle];

    for (int i = 0; i &lt; middle; i++) {
        left[i]=ary[i];            
    }

    for (int i = middle; i &lt; len; i++) {
        right[i-middle]=ary[i];
    }
    return merge(mergeSort(left), mergeSort(right));
}

@SuppressWarnings(&quot;null&quot;)
public static int[] merge(int[]left,int[] right) {
    int[] result = new int[left.length+right.length];
    int i = 0;
    int left_Pointer = 0;
    int right_Pointer = 0;
    while (left_Pointer&lt;left.length &amp;&amp; right_Pointer&lt;right.length) {
        if (left[left_Pointer] &lt;= right[right_Pointer]) {
            result [i]= left[left_Pointer];
            left_Pointer++;
            i++;     
        } else {
            result[i] = right[right_Pointer];
            right_Pointer++;
            i++;
        }
    }
    while (left_Pointer&lt;left.length) {
        result [i]= left[left_Pointer];
        left_Pointer++;
        i++;}
    while (right_Pointer&lt;right.length) {
        result[i] = right[right_Pointer];
        right_Pointer++;
        i++;}
    return result;
}</code></pre><p><strong>个人总结：关于这个并归排序算法，参考了一些晚上c语言的逻辑，采用的递归的方法，对数组分成2长度的小段，并编写逻辑，使其返回的时候排序；算法中比较难的一点，就是要使用堆栈的方法，而本程序中，使用标记指针的方法，模拟了出栈的方法和入栈的方法，并未改变数组的长度；</strong></p>
<p>算法总结:稳定；和选择排序一样（选择排序时间复杂度n^2），归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间</p>
<h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h2><p>原理：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>步骤：<br>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。  </p>
<p>java程序：  </p>
<p>算法：不稳定，时间复杂度最好 O（n log2n），最差O(n^2)  </p>
<h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>个人理解：将乱序的数组按原本的顺序存放在完全二叉树中，按照堆的特性，父结点比叶结点大，从底层到高层，再值大的点往根结点推，继而将根结点与最后的结点交换顺序，用此法循环，直到顺序排列完成<br>算法步骤：<br>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。  </p>
<p>算法：不稳定，时间复杂度最好 O（n log2n），最差O（n log2n）   </p>
<h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>个人理解：这个算法关键在于对输入数据的局限性，原本数组最大值与最小值差值太大会造成内存空间的浪费，适合数值集中的数组进行排序</p>
<p>算法步骤：<br>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。  </p>
<p>算法：稳定，时间复杂度为 O（n+k） ，比其他比较算法都快</p>
<h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。<br>个人理解：<br>算法步骤：<br>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。  </p>
<p>算法：稳定，桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。  </p>
<h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。<br>个人理解：首先对个位数排序，在对十位数进行排，以此类推到最高位<br>算法步骤：<br>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；  </p>
<p>算法：稳定，基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<hr>
<p>参考博客：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html（个人十分推荐去看这篇博客，有详细的动图，十分容易理解与掌握，强推！！！！）" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html（个人十分推荐去看这篇博客，有详细的动图，十分容易理解与掌握，强推！！！！）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhj1988.github.io/2019/06/30/程序经典排序算法个人体会与总结/" data-id="ck11jlkh2000fiouve55ojyqj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="zhj1988.github.io/2019/07/01/数据结构与算法个人总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构与算法个人总结
        
      </div>
    </a>
  
  
    <a href="zhj1988.github.io/2019/06/29/使用hexo与GitHub仓库初步搭建博客/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用hexo与GitHub仓库初步搭建博客</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/">微信公众号网页授权与模板消息发送</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/">Spring Boot 缓存应用——ehcache</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/07/html与js-学习笔记/">html与js 学习笔记</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/06/bootstrap-学习记录/">bootstrap 学习记录</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/07/24/SpringBoot结构分层解析/">SpringBoot结构分层解析 </a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZHuanJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="zhj1988.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="zhj1988.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="zhj1988.github.io/fancybox/jquery.fancybox.css">
  <script src="zhj1988.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="zhj1988.github.io/js/script.js"></script>



  </div>
</body>
</html>