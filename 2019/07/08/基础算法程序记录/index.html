<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>算法程序记录 | ZHuanJ——blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中）">
<meta property="og:type" content="article">
<meta property="og:title" content="算法程序记录">
<meta property="og:url" content="https://zhj1988.github.io/2019/07/08/基础算法程序记录/index.html">
<meta property="og:site_name" content="ZHuanJ——blog">
<meta property="og:description" content="简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中）">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-05T14:53:37.480Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法程序记录">
<meta name="twitter:description" content="简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中）">
  
    <link rel="alternate" href="zhj1988.github.io/atom.xml" title="ZHuanJ——blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="zhj1988.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="zhj1988.github.io/" id="logo">ZHuanJ——blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="zhj1988.github.io/">Home</a>
        
          <a class="main-nav-link" href="zhj1988.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="zhj1988.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zhj1988.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-基础算法程序记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="zhj1988.github.io/2019/07/08/基础算法程序记录/" class="article-date">
  <time datetime="2019-07-08T14:39:32.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法程序记录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介：记录一下碰到的比较简单但是有时候又容易忘记的算法，同时锻炼自己写代码的能力和提高程序思维，结合LeeCode的题库，然后使用java复刻（完善中）</p>
<a id="more"></a>  

<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>二分法，对有序序列进行查找</p>
<pre><code>  public static int search(int[] arr, int key) {  
    int start = 0;  
    int end = arr.length - 1;  
    while (start &lt;= end) {  
        int middle = (start + end) / 2;  
        if (key &lt; arr[middle]) {  
            end = middle - 1;  
        } else if (key &gt; arr[middle]) {  
            start = middle + 1;  
        } else {  
            return middle;  
        }  
    }  
    return -1;  
}  </code></pre><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给定数组，和一个target值，求返回数组中两个元素之和与target相等的下标</p>
<p>我的做法，首先考虑考虑两个方面，第一个是返回的是所有和与target相等的元素下标，并且不重复；如{1,3,2,2,2}，返回{0,1,2,3}<br>java程序：  </p>
<pre><code>public static int[] twoSum(int[] nums, int target) {
    int x=0;
    int y=0;
    int x1[]=new int[nums.length/2];
    int y1[]=new int[nums.length/2];
    for(int i=0;i&lt;nums.length;i++){
        if(i==0 || find(y1,i)){
            int temp=target-nums[i];
            for(int j=i+1;j&lt;nums.length;j++){
                if(nums[j]==temp &amp;&amp; find(y1,j)){
                    x1[x]=i;
                    x++;
                    y1[y]=j;
                    y++;
                    break;}
            }
        }
    }
    System.out.println(x+&quot; &quot;+y);
    if(y1[0]==0 &amp;&amp; x1[0]==0){
        return null;
    }else{
    int[] result =new int[x+y];
        for(int i=0;i&lt;result.length;i=i+2){
            result[i]=x1[i];
            result[i+1]=y1[i];
        }
    return result;}
}
public static boolean find(int[] num,int y){
    for(int i=0;i&lt;num.length;i++){
        if(y==num[i]){
            return false;
        }
    }
    return true;
}</code></pre><p>总结：考虑相对周全，但是代码繁琐，不够简洁，只适用了数组的数据结构，用int 值代替指针作用，做到链表结构逻辑</p>
<p>网上方案：<br>由于<strong>哈希查找的时间复杂度为 O(1)</strong>，所以可以利用哈希容器 map 降低时间复杂度<br>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值<br>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止<br>如果最终都没有结果则抛出异常<br>时间复杂度：O(n)   </p>
<pre><code>class Solution {
     public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i&lt; nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                return new int[] {map.get(target-nums[i]),i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
     }
}</code></pre><p>总结：使用map数据结构，map.containsKey(target - nums[i]))，整体思路简洁，采用对比的方法，没有符合的结果即继续添加，由于哈希mao的时间复杂度，尽量多使用map结构<br><strong>疑问：</strong>target为3，当添加两个2，之后添加1，返回的是第一个2下标还是第二个2下标，解决问题的关键，在于阅读map.containKey源代码  </p>
<p>针对疑问的解析：  </p>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>我的做法，使用ListNode存储结构，当判断结点都不为空时，停止循环；注意点：保存头结点，否则无法返回；<br>java程序（时间11ms）：   </p>
<pre><code>class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int sum=0;
        ListNode listNodeTemp  = new ListNode(0);
        ListNode l3= listNodeTemp ;
        int z1=0;
        int z2=0;
        while(l1!=null || l2!=null){
            int temp1=0;
            int temp2=0;
            if(l1!=null){
                temp1=l1.val;
                l1=l1.next;
            }
            if(l2!=null){
                temp2=l2.val;
                l2=l2.next;
            }
            int x =temp1+temp2+z1;
            z2=x%10;
            z1=x/10;            
            listNodeTemp.next =new ListNode (z2);
            listNodeTemp = listNodeTemp.next; 
        } 
        if(z1&gt;0){
            listNodeTemp.next =new ListNode (z1);
        }
        return l3.next;
    }
}</code></pre><p>网上解法：  </p>
<pre><code>class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry = 0;
        while(p != null || q != null){
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = x + y + carry;
            carry = sum/10;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            if(p != null) p = p.next;
            if(q != null) q = q.next;
        }
        if(carry &gt; 0){
            curr.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}</code></pre><p>总结：网上的java速度最优解法（10ms）与我大同小异，逻辑方面基本一致，差别点在于对结点的非空判断，我一次性将ListNode.val的赋值，与ListNode.next指向下一个结点完成，网上则分开判断</p>
<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>我的解法：由于第二题的教训，使用查找的时候，尽量使用Map结构，所以本次使用了Map结构，首先思考查找重复字符，使用了 map.containsKey(num[i])返回boolean来判断，同时相对应调整，现存的最大长度，设置max初始值为0，避免输入s =””;考虑了发生重复时候，返回的为重复字符的下一个下标，并且，如果重复的字符下标小于start，则不重复值，ex：abba，正确返回值为2,abb时候，start为2，abba时候，重复字符下标&lt;start,如果此时赋值，则错误；最后考虑到退出循环时候，如果一直不出现重复的字符，则max为0，所以将max与temp判断  </p>
<p>java程序（28ms）：</p>
<pre><code>class Solution {
    public static int lengthOfLongestSubstring(String s) {
        char[] num= s.toCharArray();
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int max = 0;
        int temp = 0;
        int start= 0;
        int end= 0;
        for(int i=0;i&lt;num.length;i++){
         if(map.containsKey(num[i])){
             if(max &lt; temp){
                 max=temp;
             }
             if(map.get(num[i])&gt;=start){
                 start = map.get(num[i])+1;
             }
         }
         end = i;
         map.put(num[i],i);
         temp=end-start+1;
         }
         if(max&lt;temp){
            max=temp;
         }
         return max;
    }
}</code></pre><p>网上解法（用时10ms）</p>
<pre><code>public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        int[] index = new int[128]; // current index of character
        // try to extend the range [i, j]
        for (int j = 0, i = 0; j &lt; n; j++) {
            i = Math.max(index[s.charAt(j)], i);
            ans = Math.max(ans, j - i + 1);
            index[s.charAt(j)] = j + 1;
        }
        return ans;
    }
}</code></pre><p>总结：网上解法相对简洁，变量使用少，使用s.charAt(j)获得字符，而我则是使用字符数组存储浪费内存；使用Math.max（）比较大小，使得整体简洁；最牛逼的地方在于使用int[] index=new int[128] 表示一个字节大小数组，将对应字符值比作数组下标，当有值进入时，赋予该下标对应的String s 字符所在下标+1，同理为end值；使用i来当作start值；之后在深入分析，今天就到这里吧，此解法值得看一看   </p>
<p>五、给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。假设 nums1 和 nums2 不会同时为空。</p>
<p>我的解法：<br>定义两个int middle1，middle2类型的数字来收纳可能为数组中值，若是两个数组长度和为偶数，则最终取值为（middle1+middle2）/2.0,如果除以2，则结果依旧为整型；<br>创建一个for循环，循环次数为最后得中值的下标，nums1长度为2，nums2长度为3，那么循环次数为3；<br>进入循环中，进入for循环有一个前提，即是肯定有元素可以存入middle1中，理解这点可以减少很短不必要的判断；<br>进入第一层判断，数组是否为空，分为两个数组都不为空，任一为空；第二层判断，不为空的情况，判断是否有任一数组的已经陪取空；<br>退出for循环，判断两数组和是否为偶数进行相应操作  </p>
<p>java程序（12ms）：  </p>
<pre><code>class Solution {
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int middle1 =0;
        int middle2 = 0;
        int length =(nums1.length+nums2.length)/2+1;
        double result = 0;
        int point1 = 0;
        int point2 = 0;
        for(int i=0;i&lt;length;i++){
            middle2 =middle1;
            if(nums1.length!=0 &amp;&amp; nums2.length != 0){
                if(point1&lt;nums1.length&amp;&amp;point2&lt;nums2.length) {
                    if(nums1[point1]&lt;nums2[point2]){
                        middle1=nums1[point1];
                        point1++;
                    }else{
                        middle1=nums2[point2];
                        point2++;
                    }
                }else if(point1 == nums1.length){
                    middle1=nums2[point2];
                    point2++;
                }else {
                    middle1=nums1[point1];
                    point1++;
                }} 
            else if(nums1.length==0) {
                middle1=nums2[point2];
                point2++; 
            }
            else{
                middle1=nums1[point1];
                point1++;
            }
        }
        if((nums1.length+nums2.length)%2==0){
            result = (middle1+middle2)/2.0; 
        }else{
            result = middle1;
        }
        return result;
    }
}</code></pre><p>网上程序（2ms的大神）：</p>
<pre><code>class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;

        if (m &gt; n) {
            int[] tmp = nums2;
            nums2 = nums1;
            nums1 = tmp;
            m = nums1.length;
            n = nums2.length;
        }

        if (m == 0) return (nums2[n / 2] + nums2[(n - 1) / 2]) / 2.0;

        int imax = m;
        int imin = 0;
        int i = 0, j = n / 2;
        while(imin &lt; imax) {
            i = (imax + imin) / 2;
            j = (m + n) / 2 - i;
            if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) {
                imax = i;
            }
            else if (j &gt; 0 &amp;&amp; nums2[j - 1] &gt; nums1[i]) {
                imin = i + 1;
            }
            else break;
        }

        if (imin == imax) {
            i = (imax + imin) / 2;
            j = (m + n) / 2 - i;
        }

        // System.out.println(i + &quot; &quot; + j);


        if ((m + n) % 2 == 1) {
            if (i == m) return nums2[j];
            else return Integer.min(nums1[i], nums2[j]);
        }

        if (i == 0) {
            if (j == n) return (nums1[i] + nums2[j - 1]) / 2.0;
            return (Integer.min(nums1[i], nums2[j]) + nums2[j - 1]) / 2.0;
        }
        else if (i == m) {
            if (j == 0) return (nums1[i - 1] + nums2[j]) / 2.0;
            return (Integer.max(nums1[i - 1], nums2[j - 1]) + nums2[j]) / 2.0;
        }
        else {
            return (Integer.max(nums1[i - 1], nums2[j - 1]) + Integer.min(nums1[i], nums2[j])) / 2.0;
        }
    }
}</code></pre><p>总结： </p>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。</p>
<p>网上程序：</p>
<pre><code>class Solution {
    Map&lt;Integer, Integer&gt; depth;
    Map&lt;Integer, TreeNode&gt; parent;

    public boolean isCousins(TreeNode root, int x, int y) {
        depth = new HashMap();
        parent = new HashMap();
        dfs(root, null);
        return (depth.get(x) == depth.get(y) &amp;&amp; parent.get(x) != parent.get(y));
    }

    public void dfs(TreeNode node, TreeNode par) {
        if (node != null) {
            depth.put(node.val, par != null ? 1 + depth.get(par.val) : 0);
            parent.put(node.val, par);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    }
}</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-leetcode/</a></p>
<p>总结：这一点思想相对简洁，主要难点在于创建两个map分别保存其深度和父类结点 ；其二在于递归函数中， 使用    par != null ? 1 + depth.get(par.val) : 0 判断保存并其深度1+父结点深度；</p>
<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>网上程序：<br>    public String longestPalindrome(String s) {<br>        if (s == null || s.length() &lt; 1) return “”;<br>        int start = 0, end = 0;<br>        for (int i = 0; i &lt; s.length(); i++) {<br>            int len1 = expandAroundCenter(s, i, i);<br>            int len2 = expandAroundCenter(s, i, i + 1);<br>            int len = Math.max(len1, len2);<br>            if (len &gt; end - start) {<br>                start = i - (len - 1) / 2;<br>                end = i + len / 2;<br>            }<br>        }<br>        return s.substring(start, end + 1);<br>    }</p>
<pre><code>private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/</a></p>
<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转，如果反转后整数溢出那么就返回 0。</p>
<p>网上程序（6ms）：</p>
<pre><code>class Solution {
    public int reverse(int x) {
        int res = 0;
        int of = ((1 &lt;&lt; 31) - 1) / 10;//二进制左移31位，/10为了符合while循环中的条件
        while (x != 0) {
            if (Math.abs(res) &gt; ((1 &lt;&lt; 31) - 1) / 10) return 0;
            res = res * 10 + x % 10;
            x /= 10;
        }
        return res;
    }
}</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/reverse-integer-by-jin407891080/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/reverse-integer-by-jin407891080/</a></p>
<p>总结：难点在与溢出处理，使用左移31位，找到最大值</p>
<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。  </p>
<p>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p>
<p>java程序（8ms）：</p>
<pre><code>class Solution {
    public int myAtoi(String str) {
        long sum= 0;
        int result = 0;
        int sign = 1;
        Boolean flag = true; 
        int max = Integer.MAX_VALUE;
        for(int i=0;i&lt;str.length();i++){
            char s = str.charAt(i);
            if(s != &apos; &apos; ){
                if(flag){
                    if((s&gt;=&apos;0&apos; &amp;&amp; s&lt;=&apos;9&apos;) || s==&apos;-&apos; || s==&apos;+&apos;){
                        flag = false;
                        if(s == &apos;-&apos;){
                            sign = -1;
                        }else if(s == &apos;+&apos;){

                        }
                        else{
                            sum = s-&apos;0&apos;;
                            result = (int)sum;
                        }
                    }else{
                        return 0;
                    }
                }else{
                    if(s&lt;&apos;0&apos;||s&gt;&apos;9&apos;){
                        return result*sign;
                    }else{

                        sum = sum*10;
                        sum = sum+(s-&apos;0&apos;);
                        result = (int)sum;      
                        if(sum &gt; max){
                            if(sign==1){
                                return max;
                            }else{
                                return max*sign-1;
                            }
                        }
                    }
                }

            }else{
                if(!flag){
                     return result*sign;
                }
            }
        }
        return result*sign;
    }
}</code></pre><p>总结：做法与网上解法相差不大，以Boolean判断是否 int开头，在判断是否溢出时，应处理更简洁，应整合一部分判断语句；</p>
<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>字符串匹配<br>没有解出来</p>
<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a></p>
<p>Java程序：</p>
<pre><code>public int maxArea(int[] height) {

    int size=0;
    for(int i = 1;i&lt;height.length;i++){
        int temp =0 ;
        for(int j = 0; j&lt;i;j++){
             temp = Math.max(Math.min(height[j],height[i])*(i-j),temp);
        }
        size = Math.max(size,temp);

    }
    return size;

}</code></pre><p>总结：这个题目相对比较简单一下就想到暴力列举方法，执行了一下，效果不尽人意，之后参考了解题思路写出了下面的算法</p>
<pre><code>public int maxArea(int[] height) {
        int start=0;
        int end=height.length-1;
        int max=0;
        while(start+1 &lt;= end){
            max = Math.max(max,(end-start)*Math.min(height[start],height[end]) );

            if(height[start]&lt;height[end]){
                start++;}
            else {end--;}

        }

        return max;

    }</code></pre><p>总结：采用双指针的方法，这个题目制约着容器的最大容量，一个是两端的距离长度，一个两端中最小的那个端值；通过双指针法，从两端出发，首先使长度最大，然后使用排除法，端直小的那一段向中间移动（因为端值大的移动后，容量最大值并不会出现在此种情况中），循环至两端相邻结束</p>
<h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。  </p>
<pre><code>字符          数值  
I             1  
V             5  
X             10  
L             50  
C             100  
D             500  
M             1000  </code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。  </p>
<p>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a></p>
<p>java程序：  </p>
<pre><code>class Solution {
    public String intToRoman(int num) {
        String result = &quot;&quot;;
        int n = 0;
        while(num&gt;0){
            int temp = num%10;
            num = num/10;
            result = find (temp,n) + result;
            n=n+2;
        }
        return result;

    }
    public static String  find (int temp,int n ){
        String result = &quot;&quot;;
        String[] sign = {&quot;I&quot;,&quot;V&quot;,&quot;X&quot;,&quot;L&quot;,&quot;C&quot;,&quot;D&quot;,&quot;M&quot;};
        switch(temp){
        case 0:
            result =&quot;&quot;;
            break;
        case 1:
            result = sign[n];
            break;
        case 2:
            result = sign[n]+sign[n];
            break;
        case 3:
            result = sign[n]+sign[n]+sign[n];
            break;
        case 4:
            result = sign[n] + sign[n+1];
            break;
        case 5:
            result = sign[n+1];
            break;
        case 6:
            result = sign[n+1]+ sign[n];
            break;
        case 7:
            result = sign[n+1]+ sign[n]+sign[n];
            break;
        case 8:
            result = sign[n+1]+ sign[n]+sign[n]+sign[n];
            break;
        case 9:
            result = sign[n] + sign[n+2];
            break;
        }

        return result;
    }
}</code></pre><p>总结：没什么好说的，简单的逻辑循环判断</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zhj1988.github.io/2019/07/08/基础算法程序记录/" data-id="ck11j9uxq000ixwuvku1tmr3u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="zhj1988.github.io/2019/07/10/Spring MVC入门介绍/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring MVC入门介绍
        
      </div>
    </a>
  
  
    <a href="zhj1988.github.io/2019/07/08/MyBatis配置文件详细解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MyBatis配置文件总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="zhj1988.github.io/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="zhj1988.github.io/2019/09/25/微信公众号网页授权与模板消息发送/">微信公众号网页授权与模板消息发送</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/09/09/Spring-Boot-缓存应用——ehcache/">Spring Boot 缓存应用——ehcache</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/07/html与js-学习笔记/">html与js 学习笔记</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/08/06/bootstrap-学习记录/">bootstrap 学习记录</a>
          </li>
        
          <li>
            <a href="zhj1988.github.io/2019/07/24/SpringBoot结构分层解析/">SpringBoot结构分层解析 </a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZHuanJ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="zhj1988.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="zhj1988.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="zhj1988.github.io/fancybox/jquery.fancybox.css">
  <script src="zhj1988.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="zhj1988.github.io/js/script.js"></script>



  </div>
</body>
</html>